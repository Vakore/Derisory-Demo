/**
--enemies.txt--
FUNCTIONS:
takeKb: object, which direction to apply knockback, and the timer
Use in .takeDamage() for enemies that should take knockback
Requires 'if' statements in the enemy to apply knockback.

checkCollisions: object, extra
Use after applying velocity to an enemy
Extra for for anything the requires more range to be used, such as a sword or the worm's tongue

Enemy.run: no parameters
Used to make the enemy move, attack, and anything else during gameplay. Does not run when paused.

Enemy.draw: no parameters
Draws the enemy. Used regardless if the game is paused or not.

Enemy.wallTop, enemy.wallBottom, enemy.wallLeft, enemy.wallRight
Used for when the enemy collides with a block on the collision map.

Enemy.takeDamage:



Enemy.extraCheck
extraCheck has various uses, such as testing if there is ground in front of an enemy to turn it around if there is none, like so:
    //Turn enemy around if there is no ground in front of it
    if (this.groundCheck == false) {
        this.dir = -this.dir;
        this.x += this.dir;
    }
//Reset the groundCheck
this.groundCheck = false;
    
    enemy.extraCheck = function(x, y, w, h) {
        //Check if there is block in front of worm
if (this.x + this.w * 2 > x && this.x + this.w < x + w && this.y + this.h + 2 > y && this.y - 2 < y + h && this.dir > 0
 || this.x > x && this.x - this.w < x + w && this.y + this.h + 2 > y && this.y - 2 < y + h && this.dir < 0) {
    this.groundCheck = true;
}
    }

FIX:
Tounge of Worm is not affected by if (this.hp > 0) {}
Same with Malfunctioning person
*/
var takeKb = function(obj, kb, kbtimer) {
    if (kbtimer == undefined) {
        kbtimer = 6;
    }
    obj.kbTimer = kbtimer;
    obj.kbDir = kb;
};

var checkCollisions = function(obj, extra) {
    //Make extra empty object if undefined to avoid errors
    if (extra == undefined) {
        extra = {};
    }

    //Define the array positions of testing the tile
    var startTestX = floor((obj.x - 2) / 16);
    var endTestX = floor((obj.x + obj.w + 2) / 16) + 1;
    var dirTestX = 1;
    var startTestY = floor(obj.y / 16);
    var endTestY = floor((obj.y + obj.h) / 16) + 1;
    var dirTestY = 1;

    if (obj.velX >= 0 && extra.x != undefined) {
        if (startTestX > floor(extra.x / 16)) {
            startTestX = floor(extra.x / 16);
        }
        if (extra.w != undefined && endTestX < floor((extra.x + extra.w) / 16) + 1) {
            endTestX = floor((extra.x + extra.w) / 16) + 1;
        }
    }

    if (obj.velX < 0) {
        startTestX = floor((obj.x + obj.w + 2) / 16);
        endTestX = floor((obj.x - 2) / 16) - 1;
        dirTestX = -1;
        if (extra.x != undefined) {
            if (endTestX > floor(extra.x / 16)) {
                endTestX = floor(extra.x / 16);
            }
            if (extra.w != undefined && startTestX < floor((extra.x + extra.w) / 16) + 1) {
                startTestX = floor((extra.x + extra.w) / 16) + 1;
            }
        }
    }

    if (obj.velY >= 0 && extra.y != undefined) {
        if (startTestY > floor(extra.y / 16)) {
            startTestY = floor(extra.y / 16);
        }
        if (extra.h != undefined && endTestY < floor((extra.y + extra.h) / 16) + 1) {
            endTestY = floor((extra.y + extra.h) / 16) + 1;
        }
    }

    if (obj.velY < 0) {
        startTestY = floor((obj.y + obj.h + 2) / 16);
        endTestY = floor((obj.y - 2) / 16) - 1;
        dirTestY = -1;
        if (extra.y != undefined) {
            if (endTestY > floor(extra.y / 16)) {
                endTestY = floor(extra.y / 16);
            }
            if (extra.h != undefined && startTestY < floor((extra.y + extra.h) / 16) + 1) {
                startTestY = floor((extra.y + extra.h) / 16) + 1;
            }
        }
    }

    //collisions
    /*for (var j = startTestY; j < endTestY && j < currentLevel.length; j++) {
        if (j < 0) {
            j = 0;
        }
        for (var i = startTestX; i < endTestX && i < currentLevel[j].length && dirTestX > 0
        || i > endTestX && dirTestX < 0; i += dirTestX) {
            if (i < 0 && dirTestX > 0) {
                i = 0;
            } else if (i > currentLevel[j].length && dirTestX < 0) {
                i = currentLevel[j].length;
            }*/
    startTestY = constrain(startTestY, -1, currentLevel.length - 1);
    endTestY = constrain(endTestY, -1, currentLevel.length - 1);
    if (dirTestY > 0) {
        startTestY = constrain(startTestY, 0, currentLevel.length - 1);
        endTestY = constrain(endTestY, 0, currentLevel.length - 1);
    } 
    startTestX = constrain(startTestX, -1, currentLevel[0].length);
    endTestX = constrain(endTestX, -1, currentLevel[0].length);
    if (dirTestX > 0) {
        startTestX = constrain(startTestX, 0, currentLevel[0].length);
        endTestX = constrain(endTestX, 0, currentLevel[0].length);
    } 
    for (var j = startTestY; j != endTestY; j += dirTestY) {
        for (var i = startTestX; i != endTestX; i += dirTestX) {
            switch(currentLevel[j][i]) {
                case "1":
                    collider(i * 16, j * 16, 16, 16, obj, return4s(
                             currentLevel[constrain(j - 1, 0, j)][i],
                             currentLevel[j][constrain(i + 1, i, currentLevel[j].length - 1)],
                             currentLevel[constrain(j + 1, j, currentLevel.length - 2)][i],
                             currentLevel[j][constrain(i - 1, 0, i)],
                             ["1","2","9"]));
                break;
                case "2":
                    collider(i * 16, j * 16, 16, 16, obj, return4s(
                             currentLevel[constrain(j - 1, 0, j)][i],
                             currentLevel[j][constrain(i + 1, i, currentLevel[j].length - 1)],
                             currentLevel[constrain(j + 1, j, currentLevel.length - 2)][i],
                             currentLevel[j][constrain(i - 1, 0, i)],
                             ["1","2","9"]));
                break;
                case "4":
                    //I thought about it... but nah
                    //killBox(i * 16, j * 16 + 8, 16, 8, obj);
                break;
                case "8":
                    waterCollider(i * 16, j * 16, 16, 16, obj, false);
                break;
                case "*":
                    var offsetH = 0;
                    if (currentLevel[constrain(j - 1, 0, j)][i] != "*") {offsetH = 4;}
                    waterCollider(i * 16, j * 16 + offsetH, 16, 16 - offsetH, obj, false);
                break;
                case "9":
                    collider(i * 16, j * 16, 16, 16, obj, return4s(
                             currentLevel[constrain(j - 1, 0, j)][i],
                             currentLevel[j][constrain(i + 1, i, currentLevel[j].length - 1)],
                             currentLevel[constrain(j + 1, j, currentLevel.length - 2)][i],
                             currentLevel[j][constrain(i - 1, 0, i)],
                             ["1","2","9"]));
                break;
                case "0":
                    collider(i * 16, j * 16, 16, 16, obj);
                break;
            }
                //Debug for which blocks the entity can collide with
                //fill(255, 0, 0);
                //rect(i * 16 - 1, j * 16 - 1, 18, 18);
        }
    }

    for (var i = 0; i < enemies.length; i++) {
        if (enemies[i].collider != undefined) {enemies[i].collider(obj);}
    }
};

var enemyImgs = {
//Green Slime
"slime1":{x:1,y:1,w:16,h:13},
"slime2":{x:18,y:1,w:16,h:13},
"slime3":{x:35,y:1,w:16,h:13},

"slimeParticle1":{x:142,y:1,w:6,h:6,shiftX:-3,shiftY:-3},
"slimeParticle2":{x:149,y:1,w:5,h:5,shiftX:-3,shiftY:-3},
"slimeParticle3":{x:155,y:1,w:4,h:4,shiftX:-2,shiftY:-2},
"slimeParticle4":{x:160,y:1,w:3,h:3,shiftX:-2,shiftY:-2},
"slimeParticle5":{x:161,y:2,w:1,h:1},

//Worm
"worm1":{x:52,y:1,w:16,h:9},
"worm2":{x:69,y:1,w:15,h:9},
"worm3":{x:85,y:1,w:14,h:9},
"worm4":{x:100,y:1,w:13,h:9},
"worm5":{x:114,y:1,w:12,h:9},
"wormCorpse":{x:127,y:1,w:14,h:9,shiftX:0,shiftY:0},
"wormAttack1":{x:52,y:11,w:14,h:10,shiftX:0,shiftY:-1},
"wormAttack2":{x:67,y:11,w:14,h:10,shiftX:0,shiftY:-1},
"wormAttack3":{x:82,y:11,w:14,h:10,shiftX:0,shiftY:-1},
"wormAttack4":{x:97,y:11,w:14,h:10,shiftX:0,shiftY:-1},
"wormAttack5":{x:112,y:11,w:14,h:10,shiftX:0,shiftY:-1},

//Yellow Slime
"yellowSlime1":{x:1,y:15,w:16,h:13},
"yellowSlime2":{x:18,y:15,w:16,h:13},
"yellowSlime3":{x:35,y:15,w:16,h:13},

//Fly Eggs
"flyEggs1":{x:1,y:33,w:16,h:12,shiftX:0,shiftY:2},
"flyEggs2":{x:18,y:33,w:16,h:12,shiftX:-1,shiftY:2},
"flyEggs3":{x:35,y:33,w:16,h:12,shiftX:1,shiftY:2},
"flyEggs1Yolk":{x:1,y:29,w:16,h:3,shiftX:0,shiftY:0},
"flyEggs2Yolk":{x:18,y:29,w:16,h:3,shiftX:-1,shiftY:0},
"flyEggs3Yolk":{x:35,y:29,w:16,h:3,shiftX:1,shiftY:0},
"flyEggs4Yolk":{x:52,y:29,w:12,h:5,shiftX:2,shiftY:0},
"flyEggs5Yolk":{x:65,y:29,w:10,h:6,shiftX:3,shiftY:0},
"flyEggs6Yolk":{x:77,y:29,w:16,h:5,shiftX:0,shiftY:0},
"flyEggs7Yolk":{x:94,y:29,w:14,h:6,shiftX:0,shiftY:0},
"flyEggs8Yolk":{x:109,y:29,w:12,h:6,shiftX:2,shiftY:0},

//Red Fly
"redFly1":{x:52,y:22,w:7,h:6,shiftX:0,shiftY:0},
"redFly2":{x:60,y:22,w:9,h:5,shiftX:-1,shiftY:1},
"bigRedFly1":{x:1,y:46,w:12,h:10,shiftX:0,shiftY:-2},
"bigRedFly2":{x:14,y:46,w:12,h:8,shiftX:0,shiftY:0},
"bigRedFlyCorpse":{x:138,y:32,w:12,h:8,shiftX:0,shiftY:-2},

//Red Parasite
"redParasite1":{x:18,y:74,w:14,h:11,shiftX:0,shiftY:0},
"redParasite2":{x:33,y:74,w:14,h:11,shiftX:0,shiftY:0},
"redParasite3":{x:48,y:74,w:14,h:11,shiftX:0,shiftY:0},
"redParasite4":{x:63,y:74,w:14,h:11,shiftX:0,shiftY:0},
"redParasite5":{x:78,y:74,w:14,h:11,shiftX:0,shiftY:0},
"redParasiteSwim1":{x:93,y:74,w:14,h:11,shiftX:0,shiftY:0},
"redParasiteSwim2":{x:108,y:74,w:14,h:11,shiftX:0,shiftY:0},
"redParasiteSwim3":{x:103,y:86,w:14,h:10,shiftX:0,shiftY:0},
"redParasiteSwim4":{x:118,y:86,w:14,h:11,shiftX:0,shiftY:0},
"redParasiteCorpse":{x:123,y:74,w:14,h:11,shiftX:0,shiftY:0},

//Bat
"bat1":{x:52,y:37,w:13,h:8,shiftX:-1,shiftY:0},
"bat2":{x:66,y:37,w:15,h:8,shiftX:-2,shiftY:0},
"bat3":{x:82,y:37,w:15,h:8,shiftX:-2,shiftY:0},
"bat4":{x:98,y:37,w:15,h:8,shiftX:-2,shiftY:0},
"bat5":{x:52,y:46,w:15,h:8,shiftX:-2,shiftY:0},
"batSleeping1":{x:68,y:46,w:9,h:15,shiftX:1,shiftY:0},
"batSleeping2":{x:78,y:46,w:9,h:15,shiftX:0,shiftY:0},
"batSleeping3":{x:88,y:46,w:9,h:15,shiftX:7,shiftY:0},
"batCorpse":{x:114,y:37,w:15,h:8,shiftX:-2,shiftY:1},

"spiderWall1":{x:1,y:57,w:16,h:48,shiftX:0,shiftY:0},
"spiderWall2":{x:18,y:57,w:48,h:16,shiftX:0,shiftY:0},

"pancakeBeetle2":{x:18,y:62,w:16,h:11,shiftX:0,shiftY:0},
"pancakeBeetle1":{x:35,y:62,w:16,h:11,shiftX:0,shiftY:0},
"pancakeBeetle3":{x:52,y:62,w:16,h:11,shiftX:0,shiftY:0},
"pancakeBeetle4":{x:69,y:62,w:16,h:11,shiftX:0,shiftY:0},
"pancakeBeetle5":{x:86,y:62,w:16,h:11,shiftX:0,shiftY:0},
"pancakeBeetleCorpse":{x:103,y:62,w:16,h:11,shiftX:0,shiftY:0},

"malfunctioningPersonIdle1":{x:18,y:86,w:16,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonIdle2":{x:35,y:86,w:16,h:24,shiftX:0,shiftY:-1},
"malfunctioningPersonIdle3":{x:52,y:86,w:16,h:24,shiftX:0,shiftY:-1},
"malfunctioningPersonIdle4":{x:69,y:86,w:16,h:24,shiftX:0,shiftY:-1},
"malfunctioningPersonIdle5":{x:86,y:86,w:16,h:24,shiftX:0,shiftY:-1},
"malfunctioningPersonIdle6":{x:18,y:110,w:16,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonAttack1":{x:35,y:111,w:16,h:23,shiftX:1,shiftY:0},
"malfunctioningPersonAttack2":{x:52,y:111,w:17,h:23,shiftX:1,shiftY:0},
"malfunctioningPersonAttack3":{x:70,y:111,w:15,h:23,shiftX:1,shiftY:0},
"malfunctioningPersonAttack4":{x:86,y:111,w:14,h:23,shiftX:1,shiftY:0},
"malfunctioningPersonAttack5":{x:101,y:111,w:14,h:23,shiftX:1,shiftY:0},
"malfunctioningPersonAttack6":{x:28,y:135,w:33,h:23,shiftX:1,shiftY:0},
"malfunctioningPersonAttack7":{x:62,y:135,w:20,h:23,shiftX:-1,shiftY:0},
"malfunctioningPersonAttack8":{x:83,y:135,w:19,h:23,shiftX:-1,shiftY:0},
"malfunctioningPersonAttack9":{x:103,y:135,w:17,h:23,shiftX:-1,shiftY:0},
"malfunctioningPersonJump1":{x:18,y:159,w:17,h:23,shiftX:-2,shiftY:0},
"malfunctioningPersonJump2":{x:36,y:159,w:19,h:22,shiftX:-3,shiftY:0},
"malfunctioningPersonJump3":{x:56,y:159,w:20,h:22,shiftX:-3,shiftY:0},
"malfunctioningPersonJump4":{x:77,y:159,w:23,h:22,shiftX:-4,shiftY:0},
"malfunctioningPersonJump5":{x:101,y:159,w:22,h:22,shiftX:-3,shiftY:0},
/*"malfunctioningPersonWalk1":{x:19,y:183,w:16,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonWalk2":{x:37,y:183,w:16,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonWalk3":{x:55,y:183,w:16,h:23,shiftX:0,shiftY:0},*/
"malfunctioningPersonWalk1":{x:1,y:210,w:16,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonWalk2":{x:18,y:210,w:16,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonWalk3":{x:35,y:210,w:16,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonWalk4":{x:52,y:209,w:16,h:24,shiftX:0,shiftY:-1},
"malfunctioningPersonWalk5":{x:69,y:210,w:16,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonCorpse1":{x:71,y:182,w:16,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonCorpse2":{x:88,y:182,w:17,h:23,shiftX:0,shiftY:0},
"malfunctioningPersonCorpse3":{x:86,y:206,w:23,h:17,shiftX:-4,shiftY:5},
"malfunctioningPersonCorpse4":{x:86,y:224,w:23,h:17,shiftX:-4,shiftY:7},
"malfunctioningPersonCorpse5":{x:86,y:242,w:23,h:14,shiftX:-4,shiftY:9},
"malfunctioningPersonCorpse6":{x:86,y:257,w:23,h:14,shiftX:-4,shiftY:9},


"malfunctioningRobotIdle1":{x:116,y:104,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotWalk1":{x:138,y:104,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotWalk2":{x:160,y:104,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotWalk3":{x:182,y:104,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotWalk4":{x:204,y:104,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotWalk5":{x:124,y:135,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotWalk6":{x:146,y:135,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotWalk7":{x:168,y:135,w:21,h:30,shiftX:-3,shiftY:0},

"malfunctioningRobotJump1":{x:138,y:73,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotJump2":{x:160,y:73,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotJump3":{x:182,y:73,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotJump4":{x:204,y:72,w:21,h:31,shiftX:-3,shiftY:-1},
"malfunctioningRobotLand4":{x:138,y:41,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotLand3":{x:160,y:41,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotLand2":{x:182,y:41,w:21,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotLand1":{x:204,y:40,w:21,h:31,shiftX:-3,shiftY:-1},

"malfunctioningRobotAttack1":{x:190,y:135,w:22,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotAttack2":{x:124,y:166,w:23,h:30,shiftX:-3,shiftY:0},
"malfunctioningRobotAttack3":{x:148,y:166,w:27,h:30,shiftX:-2,shiftY:0},
"malfunctioningRobotAttack4":{x:176,y:166,w:17,h:30,shiftX:0,shiftY:0},
"malfunctioningRobotAttack5":{x:194,y:166,w:17,h:32,shiftX:0,shiftY:-2},
"malfunctioningRobotAttack6":{x:124,y:197,w:17,h:34,shiftX:0,shiftY:-4},
"malfunctioningRobotAttack7":{x:142,y:197,w:17,h:34,shiftX:0,shiftY:-4},
"malfunctioningRobotAttack8":{x:142,y:197,w:17,h:34,shiftX:0,shiftY:-4},
"malfunctioningRobotAttack9":{x:160,y:197,w:27,h:28,shiftX:0,shiftY:2},
"malfunctioningRobotAttack10":{x:188,y:199,w:27,h:25,shiftX:0,shiftY:5},
"malfunctioningRobotAttack11":{x:124,y:232,w:27,h:22,shiftX:0,shiftY:7},
"malfunctioningRobotAttack12":{x:152,y:232,w:27,h:22,shiftX:0,shiftY:7},
"malfunctioningRobotAttack13":{x:180,y:232,w:27,h:22,shiftX:0,shiftY:7},

"malfunctioningRobotHead":{x:175,y:266,w:14,h:10,shiftX:0,shiftY:0},
"malfunctioningRobotBody":{x:155,y:266,w:13,h:12,shiftX:0,shiftY:0},
"malfunctioningRobotLeg":{x:146,y:266,w:8,h:9,shiftX:0,shiftY:0},
"malfunctioningRobotArm":{x:169,y:266,w:5,h:10,shiftX:0,shiftY:0},

"electricShot1":{x:124,y:255,w:10,h:10,shiftX:0,shiftY:0},
"electricShot2":{x:135,y:255,w:10,h:10,shiftX:0,shiftY:0},
"electricShot3":{x:146,y:255,w:10,h:10,shiftX:0,shiftY:0},
"electricShot4":{x:157,y:255,w:10,h:10,shiftX:0,shiftY:0},
"electricShot5":{x:168,y:255,w:10,h:10,shiftX:0,shiftY:0},
"electricShot6":{x:179,y:255,w:10,h:10,shiftX:0,shiftY:0},

"sleepDropper1":{x:181,y:1,w:16,h:16,shiftX:0,shiftY:0},
"sleepDropper2":{x:164,y:1,w:16,h:15,shiftX:0,shiftY:0},
"sleepDropperPellet":{x:155,y:6,w:5,h:5,shiftX:-1,shiftY:-1},


"sleepFrogCorpse":{x:318,y:15,w:22,h:6,shiftX:-3,shiftY:3},
"sleepFrogIdle1":{x:226,y:1,w:22,h:12,shiftX:-3,shiftY:-3},
"sleepFrogJump1":{x:249,y:1,w:22,h:12,shiftX:-3,shiftY:-3},
"sleepFrogJump2":{x:272,y:1,w:22,h:11,shiftX:-3,shiftY:-2},
"sleepFrogJump3":{x:295,y:1,w:22,h:14,shiftX:-3,shiftY:-3},
"sleepFrogJump4":{x:318,y:1,w:22,h:12,shiftX:-3,shiftY:-3},
"sleepFrogJump5":{x:341,y:1,w:21,h:13,shiftX:-3,shiftY:-3},
"sleepFrogJump6":{x:363,y:1,w:22,h:13,shiftX:-4,shiftY:-3},
"sleepFrogJump7":{x:386,y:1,w:21,h:13,shiftX:-4,shiftY:-3},
"sleepFrogSleep1":{x:295,y:16,w:22,h:8,shiftX:-3,shiftY:1},
"sleepFrogSleep2":{x:272,y:13,w:22,h:8,shiftX:-3,shiftY:1},
"sleepFrogSleep3":{x:249,y:14,w:22,h:9,shiftX:-3,shiftY:0},
"sleepFrogSleep4":{x:226,y:14,w:22,h:10,shiftX:-4,shiftY:-1},
"sleepFrogSpit1":{x:341,y:15,w:22,h:12,shiftX:-3,shiftY:-3},
"sleepFrogSpit2":{x:364,y:15,w:22,h:13,shiftX:-3,shiftY:-4},
"sleepFrogSpit3":{x:387,y:15,w:22,h:14,shiftX:-3,shiftY:-5},
"sleepFrogChew1":{x:410,y:15,w:22,h:12,shiftX:-3,shiftY:-3},
"sleepFrogChew2":{x:410,y:28,w:22,h:12,shiftX:-3,shiftY:-3},
"sleepFrogChew3":{x:410,y:41,w:22,h:12,shiftX:-3,shiftY:-3},
"sleepFrogSpitAir1":{x:353,y:30,w:6,h:10,shiftX:0,shiftY:-2},
"sleepFrogSpitAir2":{x:360,y:30,w:8,h:8,shiftX:-1,shiftY:-1},
"sleepFrogSpitAir3":{x:369,y:30,w:10,h:6,shiftX:-2,shiftY:0},
"sleepFrogSpitGround1":{x:380,y:30,w:9,h:4,shiftX:-1,shiftY:-1},
"sleepFrogSpitGround2":{x:390,y:30,w:9,h:5,shiftX:-1,shiftY:-2},
"sleepFrogSpitGround3":{x:400,y:30,w:9,h:3,shiftX:-1,shiftY:0},
};

var corpse = function(x, y, w, h, velX, velY, dir, sprite, spriteSrc, spriteSrc2, instaGo) {
    this.ded = false;
    this.aliveTimer = 500;
    this.instaGo = instaGo;

    //The Defaults
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.velX = velX;
    if (velX.toString() === velX) {this.velX = 0;}
    this.velY = velY;
    this.sprite = sprite;
    this.hp = 2;
    this.immuneTimers = [-10, -10];
    this.inWater = false;

    this.dir = dir;
    this.spriteSrc = spriteSrc;
    this.spriteSrc2 = spriteSrc2;
    if (!this.spriteSrc) {
        this.spriteSrc = "enemySprites";
    }
    if (!this.spriteSrc2) {
        this.spriteSrc2 = enemyImgs;
    }
    this.displayY = this.spriteSrc2[this.sprite].h;
};

corpse.prototype.run = function() {
    this.velY += 0.1;
    this.x += this.velX;
    this.y += this.velY;

    //COLLISION CHECK
    checkCollisions(this);
    //COLLISION CHECK
    this.aliveTimer--;
    if (this.aliveTimer < 0) {
        if (!this.instaGo) {
            this.displayY--;
        } else {
            this.displayY -= abs(this.velY);
        }
    }
    if (this.displayY <= 0) {
        this.ded = true;
    }
};

corpse.prototype.drawBack = function() {
    save();
    translate(round(this.x), round(this.y));
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image(this.spriteSrc, {
                  "x":this.spriteSrc2[this.sprite].x,
                  "y":this.spriteSrc2[this.sprite].y,
                  "w":this.spriteSrc2[this.sprite].w,
                  "h":this.displayY,
                  "shiftX":this.spriteSrc2[this.sprite].shiftX,
                  "shiftY":this.spriteSrc2[this.sprite].shiftY + this.spriteSrc2[this.sprite].h - this.displayY,
              }, 0, 0);
    }
    restore();
};
corpse.prototype.draw = function() {};

corpse.prototype.wallTop = function() {
    if (!this.instaGo) {
        this.velX = 0;
        this.velY = 0;
        if (this.aliveTimer > 200) {
            this.aliveTimer = 200;
        }
    } else if (this.aliveTimer > 0 && this.instaGo) {
        this.aliveTimer = 0;
    }
};
corpse.prototype.wallLeft = function() {this.velX = 0;};
corpse.prototype.wallRight = function() {this.velX = 0;};
corpse.prototype.wallBottom = function() {this.velY = 0;};

var malfunctioningCorpse = function(x, y, w, h, velX, velY, dir, sprite, spriteSrc, spriteSrc2, instaGo) {
    this.ded = false;
    this.aliveTimer = 500;
    this.instaGo = instaGo;

    //The Defaults
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.velX = velX;
    if (velX.toString() === velX) {this.velX = 0;}
    this.velY = velY;
    this.sprite = sprite;
    this.hp = 2;
    this.immuneTimers = [-10, -10];
    this.inWater = false;

    this.dir = dir;
    this.spriteSrc = spriteSrc;
    this.spriteSrc2 = spriteSrc2;
    if (!this.spriteSrc) {
        this.spriteSrc = "enemySprites";
    }
    if (!this.spriteSrc2) {
        this.spriteSrc2 = enemyImgs;
    }
    this.displayY = this.spriteSrc2[this.sprite].h;
    this.spriteTimer = 1;
};

malfunctioningCorpse.prototype.run = function() {
    this.velY += 0.1;
    this.x += this.velX;
    this.y += this.velY;

    //COLLISION CHECK
    checkCollisions(this);
    //COLLISION CHECK
    this.spriteTimer += 0.2;
    if (this.velY != 0 && floor(this.spriteTimer) > 3) {
        this.spriteTimer = 3;
    } else if (floor(this.spriteTimer) > 6) {
        this.spriteTimer = 6;
    }
    this.sprite = "malfunctioningPersonCorpse" + floor(this.spriteTimer);
    if (this.aliveTimer > 0) {
        this.displayY = this.spriteSrc2[this.sprite].h;
    }
    this.aliveTimer--;
    if (this.aliveTimer < 0) {
        if (!this.instaGo) {
            this.displayY--;
        } else {
            this.displayY -= abs(this.velY);
        }
    }
    if (this.displayY <= 0) {
        this.ded = true;
    }
};

malfunctioningCorpse.prototype.drawBack = function() {
    save();
    translate(round(this.x), round(this.y));
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image(this.spriteSrc, {
                  "x":this.spriteSrc2[this.sprite].x,
                  "y":this.spriteSrc2[this.sprite].y,
                  "w":this.spriteSrc2[this.sprite].w,
                  "h":this.displayY,
                  "shiftX":this.spriteSrc2[this.sprite].shiftX,
                  "shiftY":this.spriteSrc2[this.sprite].shiftY + this.spriteSrc2[this.sprite].h - this.displayY,
              }, 0, 0);
    }
    restore();
};
malfunctioningCorpse.prototype.draw = function() {};

malfunctioningCorpse.prototype.wallTop = function() {
    if (!this.instaGo) {
        this.velX = 0;
        this.velY = 0;
        if (this.aliveTimer > 200) {
            this.aliveTimer = 200;
        }
    } else if (this.aliveTimer > 0 && this.instaGo) {
        this.aliveTimer = 0;
    }
};
malfunctioningCorpse.prototype.wallLeft = function() {this.velX = 0;};
malfunctioningCorpse.prototype.wallRight = function() {this.velX = 0;};
malfunctioningCorpse.prototype.wallBottom = function() {this.velY = 0;};

/////////////////////////////////////////
//////////SLIME DEATH PARTICLES//////////
/////////////////////////////////////////
var slimeParticle = function(x, y, velX, velY, spriteTimer) {
    this.ded = false;
    //The Defaults
    this.x = x;
    this.y = y;
    this.w = 5;
    this.h = 5;
    this.velX = velX;
    this.velY = velY;
    this.sprite = "slimeParticle1";
    this.hp = 100;
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.spriteTimer = spriteTimer;
};
slimeParticle.prototype.run = function() {
    this.velY += 0.1;
    this.x += this.velX;
    this.y += this.velY;
    this.spriteTimer += 0.1;
    if (floor(this.spriteTimer) > 5) {
        this.spriteTimer = 5;
        this.ded = true;
    }
    this.sprite = "slimeParticle" + floor(this.spriteTimer);
};
slimeParticle.prototype.draw = function() {
    //Render the big red fly
    if (this.hp > 0 && checkBlinking(this)) {
        save();
        translate(this.x, this.y);
        if (this.dir < 0) {translate(this.w, 0);}
        scale(this.dir, 1);
        image("enemySprites", enemyImgs[this.sprite], 0, 0);
        restore();
    }
};

/////////////////////////////////////////
//////////////SLIME FUNCTION/////////////
/////////////////////////////////////////
var Slime = function(x, y, speed) {
    this.ded = false;

    //The Defaults
    this.x = x;
    this.y = y;
    this.w = 16;
    this.h = 16;
    this.velX = 0;
    this.velY = 0;
    this.sprite = "slime1";
    this.hp = 2;
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.spriteTimer = 0;
    this.slimeFrames = ["slime3","slime1","slime2","slime1"];

    //The seconds
    this.speed = speed;
    this.dir = 0;
};

Slime.prototype.run = function() {
    this.isGrounded--;

    if (this.isGrounded < 0) {
        if (this.dir == 0 && this.speed > 0 || this.dir == 2 && this.speed < 0) {
            this.wallRight();
        } else if (this.dir == 1 && this.speed > 0 || this.dir == 3 && this.speed < 0) {
            this.wallBottom();
        } else if (this.dir == 2 && this.speed > 0 || this.dir == 0 && this.speed < 0) {
            this.wallLeft();
        } else if (this.dir == 3 && this.speed > 0 || this.dir == 1 && this.speed < 0) {
            this.wallTop();
        }
    }

    if (this.dir == 0) {
        this.velX = this.speed;
        this.velY = 1;
    } else if (this.dir == 1) {
        this.velX = -1;
        this.velY = this.speed;
    } else if (this.dir == 2) {
        this.velX = -this.speed;
        this.velY = -1;
    } else if (this.dir == 3) {
        this.velX = 1;
        this.velY = -this.speed;
    }
    this.x += this.velX;
    this.y += this.velY;

    if (this.dir == 0) {
        this.x2 = this.x + 2;
        this.y2 = this.y + 5;
        this.w2 = 12;
        this.h2 = 10;
    } else if (this.dir == 1) {
        this.x2 = this.x + 2;
        this.y2 = this.y + 2;
        this.w2 = 9;
        this.h2 = 12;
    } else if (this.dir == 2) {
        this.x2 = this.x + 2;
        this.y2 = this.y + 2;
        this.w2 = 12;
        this.h2 = 9;
    } else if (this.dir == 3) {
        this.x2 = this.x + 5;
        this.y2 = this.y + 2;
        this.w2 = 9;
        this.h2 = 12;
    }
    if (this.hp > 0) {
        attackBox(this.x, this.y, this.w, this.h, this);
        if (this.hp > 0) {damageBox(this.x2, this.y2, this.w2, this.h2, 1);}
    } else {
        this.ded = true;
        for (var i = 0; i < 3; i++) {
            enemies.push(new slimeParticle(this.x + this.w / 2, this.y + this.h / 2, random(-2, 2), random(-2, 1), round(random(1, 2))));
        }
    }


    //CHECK COLLISIONS
    checkCollisions(this);
    //CHECK COLLISIONS

    //Displaying the Slime
    this.spriteTimer += 0.1;
    if (this.spriteTimer >= 4) {this.spriteTimer = 0;}
    this.sprite = this.slimeFrames[floor(this.spriteTimer)];
};


/////////////////////////////////////////
//////////////DRAW SLIME/////////////////
/////////////////////////////////////////
Slime.prototype.draw = function() {
    save();
    translate(this.x, this.y);
    if (this.dir == 0) {
        translate(0, 3);
    } else if (this.dir == 1) {
        translate(13, 0);
    } else if (this.dir == 2) {
        translate(16, 13);
    } else if (this.dir == 3) {
        translate(3, 16);
    }
    rotate(this.dir * 90);
    if (this.speed < 0) {
        translate(16, 0);
        scale(-1, 1);
    }
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], 0, 0, 16, 13);
    }
    restore();
};

//SLIME TAKING DAMAGE
Slime.prototype.takeDamage = function(amount) {
    this.hp -= amount;
    playSound("slimeHurt" + round(random(1, 2)), 0.6);
    for (var i = 0; i < 3; i++) {
        enemies.push(new slimeParticle(this.x + this.w / 2, this.y + this.h / 2, random(-2, 2), random(-2, -1), round(random(1, 2))));
    }
};

//SLIME COLLISIONS

Slime.prototype.wallTop = function() {
    if (this.dir == 3 && this.speed > 0 | this.speed < 0 & this.isGrounded > 0 || this.dir == 1 && this.speed < 0 | this.speed > 0 & this.isGrounded > 0) {
        this.dir = 0;
    }
    this.isGrounded = 2;
};

Slime.prototype.wallLeft = function() {
    if (this.dir == 2 && this.speed > 0 | this.speed < 0 & this.isGrounded > 0 || this.dir == 0 && this.speed < 0 | this.speed > 0 & this.isGrounded > 0) {
        this.dir = 3;
        this.y -= abs(this.speed);
    }
    this.isGrounded = 2;
};

Slime.prototype.wallRight = function() {
    if (this.dir == 0 && this.speed > 0 | this.speed < 0 & this.isGrounded > 0 || this.dir == 2 && this.speed < 0 | this.speed > 0 & this.isGrounded > 0) {
        this.dir = 1;
        this.y--;
    }
    this.isGrounded = 2;
};

Slime.prototype.wallBottom = function() {
    if (this.dir == 1 && this.speed > 0 | this.speed < 0 & this.isGrounded > 0 || this.dir == 3 && this.speed < 0 | this.speed > 0 & this.isGrounded > 0) {
        this.dir = 2;
        this.x -= this.speed;
    }
    this.isGrounded = 2;
};

/////////////////////////////////////////
/////////////WORM FUNCTION///////////////
/////////////////////////////////////////
var Worm = function(x, y) {
    this.ded = false;

    //The Defaults
    this.x = x;
    this.y = y;
    this.w = 16;
    this.h = 9;
    this.velX = 0;
    this.velY = 1;
    this.hp = 3;
    this.immuneTimers = [-10,-10];
    this.inWater = false;
    this.sprite = "worm1";
    this.spriteTimer = 0;
    this.wormSprites = ["worm1", "worm2", "worm3", "worm4", "worm5", "worm4", "worm3", "worm2"];
    //The seconds
    this.dir = 1;
    this.toungeW = 0;
    this.attacking = 0;
    this.toungeTimer = 2;
    this.spawnTimer = 10;
    this.groundCheck = false;

    this.willAttack = -1;
};

Worm.prototype.run = function() {
    if (this.spawnTimer > 0) {this.spawnTimer--;}
    //Turn worm around if there is no ground in front of it
    if (this.groundCheck == false && this.spawnTimer <= 0) {
        this.dir = -this.dir;
        //this.x += this.dir;
    }

    //Reset the groundCheck
    this.groundCheck = false;

    this.velX = 0;
    if (floor(this.spriteTimer) >= 5 | floor(this.spriteTimer == 0) && this.toungeW <= 0) {
        this.velX = this.dir * 0.25;
    } else {
        //this.x = floor(this.x);
    }

    if (this.willAttack > -5) {
    this.willAttack--;
    }

    //Check if a player is in front of the worm, and if so, start the attack
    for (var i = 0; i < players.length; i++) {
        if (players[i].x + players[i].w > this.x + this.w & players[i].x < this.x + this.w + 48 & this.dir == 1 |
            players[i].x + players[i].w > this.x - 48 & players[i].x < this.x & this.dir == -1
            && players[i].y + players[i].h > this.y && players[i].y < this.y + this.h && this.toungeTimer <= 0 && this.attacking == 0) {
            this.attacking = 2;
            this.willAttack = 15;
            playSound("wormAttack");
        }
    }

    if (this.attacking == 2 && this.willAttack < 0) {
        this.attacking = 1;
    }

    //If the player is attacking, stop the worm and extend/retract the tounge
    if (abs(this.attacking) == 1) {
        this.toungeW += this.attacking * 5;
        this.velX = 0;
    } else if (this.willAttack > 0) {
        this.velX = 0;
    }
    //If the tougne's Width reaches a certain lenth, retract it and set the delay of the next attack to 60 frames
    if (this.toungeW > 40 && this.attacking == 1) {
        this.attacking = 0;
        this.toungeTimer = 20;
    } else if (this.toungeW >= 40 && this.attacking == 0 && this.toungeTimer <= 1) {
        this.attacking = -1;
        this.toungeTimer = 60;
    }

    //Create a hitbox around the tounge accordding to the worm's width and direction
    if (this.toungeW < 0) {
        this.tougneW = 0;
        if (this.attacking < 2) {
            this.attacking = 0;
        }
    } else if (this.toungeW > 0 && this.dir > 0 && this.hp > 0) {
        damageBox(this.x + 13, this.y + 6, this.toungeW, 1, 1);
    } else if (this.toungeW > 0 && this.dir < 0 && this.hp > 0) {
        damageBox(this.x - this.toungeW + 3, this.y + 6, this.toungeW, 1, 1);
    }

    if (this.kbTimer > 0) {
        if (this.kbDir == 1) {
            this.velX = this.kbTimer;
        } else if (this.kbDir == -1) {
            this.velX = -this.kbTimer;
        } else {
            this.velX = 0;
        }
    }
    if (this.spawnTimer > 0) {this.velX = 0;}
    this.x += this.velX;
    this.y += this.velY;
    this.velY += 0.1;

    this.x2 = this.x + 1;
    this.y2 = this.y + 1;
    this.w2 = this.w - 2;
    this.h2 = this.h - 2;

    this.toungeTimer--;
    if (!this.attacking && this.toungeW <= 0) {
        this.spriteTimer += 0.25;
    }
    if (floor(this.spriteTimer) > 7) {
        this.spriteTimer = 0;
    }

    if (this.dir > 0) {
        this.x2 += 16 - enemyImgs[this.sprite].w;
    }
    this.w2 -= 16 - enemyImgs[this.sprite].w;



    //CHECK COLLISIONS
    if (this.toungeW <= 0) {
        checkCollisions(this);
    } else if (this.toungeW > 0 && this.dir > 0 && this.hp > 0) {
        checkCollisions(this, {x:this.x + 13,w:this.toungeW});
    } else if (this.toungeW > 0 && this.dir < 0 && this.hp > 0) {
        checkCollisions(this, {x:this.x - this.toungeW + 3,w:this.toungeW});
    }
    //CHECK COLLISIONS

    if (this.hp > 0) {
        attackBox(this.x2 - 1, this.y, this.w2 + 2, this.h, this);
        if (this.hp > 0) {
            damageBox(this.x2, this.y2, this.w2, this.h2, 1);
            //Create a hitbox around the tounge accordding to the worm's width and direction
            if (this.toungeW < 0) {
                this.tougneW = 0;
                if (this.attacking < 2) {
                    this.attacking = 0;
                }
            } else if (this.toungeW > 0 && this.dir > 0) {
                damageBox(this.x + 13, this.y + 6, this.toungeW, 1, 1);
            } else if (this.toungeW > 0 && this.dir < 0) {
                damageBox(this.x - this.toungeW + 3, this.y + 6, this.toungeW, 1, 1);
            }
        }
    } else {
        this.ded = true;
        enemies.push(new corpse(this.x, this.y, this.w, this.h, this.kbDir, -2, this.dir, "wormCorpse"));
    }

    //Set the worms Sprite to whatever the spriteTimer is
    this.sprite = this.wormSprites[floor(this.spriteTimer)];
    //If the worm is about to attack, set the spriteTimer to 3 and change the sprite to an attacking sprite
    if (this.willAttack > 0) {
        this.spriteTimer = 3;
        this.sprite = "wormAttack" + (ceil((30 - this.willAttack) / 6));
    }
};

/////////////////////////////////////////
//////////////DRAW WORM//////////////////
/////////////////////////////////////////
Worm.prototype.draw = function() {
    save();
    translate(this.x, this.y);
    if (this.dir < 0) {translate(16, 0);}
    can.scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], 16-enemyImgs[this.sprite].w, 0);
        if (this.toungeW > 0) {
            fill(255, 0, 0);
            rect(13, 6, this.toungeW, 1);
        }
    }
    restore();
};

//WORM TAKING DAMAGE
Worm.prototype.takeDamage = function(amount, kb) {
    playSound("wormDamage");
    this.hp -= amount;
    takeKb(this, kb, 5);
};

//WORM COLLIDING
Worm.prototype.wallTop = function() {
    this.velY = 0;
};

Worm.prototype.wallLeft = function() {
    this.dir = -1;
    this.groundCheck = true;
};

Worm.prototype.wallRight = function() {
    this.dir = 1;
    this.groundCheck = true;
};

Worm.prototype.wallBottom = function() {};

Worm.prototype.extraCheck = function(x, y, w, h) {
//Check if tounge is touching block
if (this.attacking > 0 && this.y + 6 > y && this.y + 1 < y + h) {
    if (
    this.x + 13 < x + w && this.x + 13 + this.toungeW > x && this.dir > 0 ||
    this.x - this.toungeW + 3 < x + w && this.x + 3 > x && this.dir < 0) {
        this.attacking = -1;
        this.toungeTimer = 60;
    }
}

//Check if there is block in front of worm
if (this.x + this.w * 2 > x && this.x + this.w < x + w && this.y + this.h + 2 > y && this.y - 2 < y + h && this.dir > 0
 || this.x > x && this.x - this.w < x + w && this.y + this.h + 2 > y && this.y - 2 < y + h && this.dir < 0) {
    this.groundCheck = true;
}

};

/////////////////////////////////////////
///////YELLOW SLIME FUNCTION/////////////
/////////////////////////////////////////
var YellowSlime = function(x, y) {
    //The Defaults
    this.x = x;
    this.y = y + 3;
    this.w = 16;
    this.h = 13;
    this.velX = 0;
    this.velY = 0;
    this.sprite = "yellowSlime1";
    this.hp = 2;
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.spriteTimer = 0;
    this.slimeFrames = ["yellowSlime1","yellowSlime2","yellowSlime1","yellowSlime3"];
    this.target = floor(random(0, players.length));
    if (this.target >= players.length) {
        this.target = 1;
    }

    //The seconds
    this.isGrounded = 25;
    this.dir = 1;
};

YellowSlime.prototype.run = function() {
    this.velY += 0.1;
    this.y += this.velY;
    this.isGrounded--;
    if (this.isGrounded < 0) {
        this.velY = -2.5;
        this.isGrounded = 90;
    }
    if (this.hp > 0) {
        attackBox(this.x, this.y, this.w, this.h, this);
        if (this.hp > 0) {damageBox(this.x + 1, this.y + 2, this.w - 2, this.h - 4, 1);}
    } else {
        this.ded = true;
    }

    //CHECK COLLISIONS
    checkCollisions(this);
    //CHECK COLLISIONS

    //Sprite stuff
    this.spriteTimer += 0.1;
    if (this.spriteTimer >= 4) {this.spriteTimer = 0;}
    this.sprite = this.slimeFrames[floor(this.spriteTimer)];

    //Detect if the player is behind or in front of the yellow slime
    if (players[this.target].x < this.x) {
        this.dir = -1;
    } else {
        this.dir = 1;
    }
};

YellowSlime.prototype.draw = function() {
    //Display the yellow slime
    save();
    translate(this.x, this.y);
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], 0, 0);
    }
    restore();
};

//YELLOW SLIME TAKING DAMAGE
YellowSlime.prototype.takeDamage = function(amount) {
    this.hp -= amount;
};

YellowSlime.prototype.wallTop = function() {
    this.velY = 0;
};

/////////////////////////////////////////
////////////RED FLY FUNCTION/////////////
/////////////////////////////////////////
var RedFly = function(x, y, velX, velY, alwaysChase) {
    this.ded = false;

    //The defaults
    this.x = x;
    this.y = y;
    this.w = 7;
    this.h = 5;
    this.immuneTimers = [-10,-10];
    this.inWater = false;
    this.velX = velX;
    this.velY = velY;
    if (velX) {this.velX = velX;}
    if (velY) {this.velY = velY;}
    this.alwaysChase = alwaysChase;
    if (!this.alwaysChase) {this.alwaysChase = false;}
    this.hp = 1.5;
    this.sprite = "redFly1";
    this.spriteTimer = 0;
    this.flyFrames = ["redFly1","redFly2"];
    this.chasingPlayer = true;

    this.target = 0;//By default, target player 1
};

RedFly.prototype.run = function() {
    //Update the sprite timer
    this.spriteTimer += 0.25;
    if (floor(this.spriteTimer) > 1) {
        this.spriteTimer = 0;
    }

    //Set the sprite
    this.sprite = this.flyFrames[floor(this.spriteTimer)];

    //Only update the velocities if the fly is within a certain distance of the player, otherwise stop
    if (this.chasingPlayer && dist(this.x + 3, this.y + 2, players[this.target].x + 7, players[this.target].y + 11) < 160 || this.alwaysChase) {
        //Update the x velocity
        if (players[this.target].x < this.x + this.w / 2) {
            this.velX -= random(0.025, 0.075) * (this.inWater ? 0.5 : 1);
        } else if (players[this.target].x > this.x + this.w / 2) {
            this.velX += random(0.025, 0.075) * (this.inWater ? 0.5 : 1);
        }
        //Update the y velocity
        if (players[this.target].y < this.y + this.h / 2) {
            this.velY -= random(0.01, 0.05) * (this.inWater ? 0.5 : 1);
        } else if (players[this.target].y > this.y + this.h / 2) {
            this.velY += random(0.01, 0.05) * (this.inWater ? 0.5 : 1);
        }
    } else {
        if (dist(this.x + 3, this.y + 2, players[this.target].x + 7, players[this.target].y + 11) < 100) {
            this.chasingPlayer = true;
        } else {
            this.chasingPlayer = false;
        }
        if (abs(this.velX) < 0.1) {
            this.velX = 0;
        } else {
            this.velX /= 1.05;
        }
        if (abs(this.velY) < 0.1) {
            this.velY = 0;
        } else {
            this.velY /= 1.05;
        }
    }

    //constrain the x and y velocities
    this.velX = constrain(this.velX, -1.8, 1.8);
    this.velY = constrain(this.velY, -1.8, 1.8);
    if (this.inWater) {
        this.velX = constrain(this.velX, -1.4, 1.4);
        this.velY = constrain(this.velY, -1.4, 1.4);
    }

    if (this.kbTimer > 0) {
        if (this.kbDir == 1) {
            this.velX = this.kbTimer;
        } else if (this.kbDir == -1) {
            this.velX = -this.kbTimer;
        } else if (this.kbDir == "Down") {
            this.velY = this.kbTimer;
        } else if (this.kbDir == "Up") {
            this.velY = -this.kbTimer;
        }
    }

    //Move the fly
    this.x += this.velX;
    this.y += this.velY;

    if (this.hp > 0) {
        attackBox(this.x, this.y, this.w, this.h, this);
        if (this.hp > 0) {damageBox(this.x + 2, this.y + 1, this.w - 4, this.h - 2, 1);}
    } else {
        this.ded = true;
    }

    //CHECK COLLISIONS
    this.inWater = false;
    checkCollisions(this);
    //CHECK COLLISIONS
};

RedFly.prototype.draw = function() {
    //Display the Red Fly
    if (this.hp > 0 && checkBlinking(this)) {
        can.drawImage(getId("enemySprites"), enemyImgs[this.sprite].x, enemyImgs[this.sprite].y, enemyImgs[this.sprite].w, enemyImgs[this.sprite].h,
                      this.x + enemyImgs[this.sprite].shiftX, this.y + enemyImgs[this.sprite].shiftY, enemyImgs[this.sprite].w, enemyImgs[this.sprite].h);
    }
};

RedFly.prototype.takeDamage = function(amount, kb) {
    playSound("redFlyDamage" + floor(random(1, 3.9999)));
    this.hp -= amount;
    takeKb(this, kb);
};

RedFly.prototype.wallTop = function() {this.velY = 0;};
RedFly.prototype.wallLeft = function() {this.velX = 0;};
RedFly.prototype.wallRight = function() {this.velX = 0;};
RedFly.prototype.wallBottom = function() {this.velY = 0;};


/////////////////////////////////////////
/////////GONE FLY EGGS FUNCTION//////////
/////////////////////////////////////////
var FlyEggsGone = function(x, y) {
    this.x = x;
    this.y = y;
    this.immuneTimers = [-10,-10];
    this.inWater = false;
};

FlyEggsGone.prototype.run = function() {
    //image("enemySprites", enemyImgs["flyEggs8Yolk"], this.x, this.y);
};

FlyEggsGone.prototype.draw = function() {
    image("enemySprites", enemyImgs["flyEggs8Yolk"], this.x, this.y);
};


/////////////////////////////////////////
///////////FLY EGGS FUNCTION/////////////
/////////////////////////////////////////
var FlyEggs = function(x, y) {
    this.ded = false;
    this.startX = x;
    this.startY = y;

    //The defaults
    this.x = x;
    this.y = y;
    this.w = 16;
    this.h = 14;
    this.immuneTimers = [-10,-10];
    this.inWater = false;
    this.velY = 0;
    this.hp = 2;
    this.sprite = "flyEggs2";
    this.sprite2 = "flyEggs2";
    this.spriteTimer = 0;
    this.flyFrames = ["flyEggs1", "flyEggs2", "flyEggs1", "flyEggs3"];

    this.target = 0;//By default, target player 1
    this.fallTimer = 0;
    this.fallH = 16;
    for (var i = floor(this.y / 16) + 1; i < currentLevel.length - 1; i++) {
        if (currentLevel[i][floor(this.x / 16)] != "-" && currentLevel[i][floor(this.x / 16)] != "8") {
            i = currentLevel.length;
        } else {
            this.fallH += 16;
        }
    }
};


FlyEggs.prototype.run = function() {
    this.spriteTimer += 0.1;

    if (floor(this.spriteTimer) > 3) {
        this.spriteTimer = 0;
    }

    if (this.hp > 0) {
       attackBox(this.x, this.y, this.w, this.h, this);
       if (this.hp > 0) {damageBox(this.x + 1, this.y, this.w - 2, this.h - 2, 1);}
    } else {
        this.ded = true;
        enemies.push(new FlyEggsGone(this.startX, this.startY));
    }
    //-scrollY < this.y is to ensure that the eggs do not fall on the player if they are above the screen
    if (-scrollY < this.y) {
        for (var i = 0; i < players.length && this.fallTimer == 0; i++) {
            if (players[i].x + players[i].w > this.x && players[i].x < this.x + this.w && players[i].y > this.y && players[i].y < this.y + this.fallH) {
                this.fallTimer++;
                playSound("redFlyHatch", 0.4);
            }
        }
    }
    if (this.fallTimer > 0) {this.fallTimer++;}

    if (this.fallTimer > 0) {this.velY += 0.1;}

    this.y += this.velY;

    this.sprite = this.flyFrames[floor(this.spriteTimer)];
    this.sprite2 = this.flyFrames[floor(this.spriteTimer)];
    if (this.fallTimer > 12) {
        this.sprite2 = "flyEggs8";
    } else if (this.fallTimer > 9) {
        this.sprite2 = "flyEggs7";
    } else if (this.fallTimer > 6) {
        this.sprite2 = "flyEggs6";
    } else if (this.fallTimer > 3) {
        this.sprite2 = "flyEggs5";
    } else if (this.fallTimer > 0) {
        this.sprite2 = "flyEggs4";
    }

    this.sprite2 += "Yolk";

    //CHECK COLLISIONS
    if (!this.ded) {
        checkCollisions(this);
    }
    //CHECK COLLISIONS
    if (this.inWater) {this.wallTop();}
};

FlyEggs.prototype.draw = function() {
    //Draw the Fly Eggs
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], this.x, this.y);
        image("enemySprites", enemyImgs[this.sprite2], this.startX, this.startY);
    }
};

//FLY EGGS TAKING DAMAGE
FlyEggs.prototype.takeDamage = function(amount) {
    this.hp -= amount;
    playSound("redFlyEggsHurt", 0.4);
};

//Destroy when it hits the ground
FlyEggs.prototype.wallTop = function() {
    playSound("redFlyEggsHurt", 0.4);
    this.ded = true;
    enemies.push(new FlyEggsGone(this.startX, this.startY), new RedFly(this.x, this.y, -1, -1),/*new RedFly(this.x + 4, this.y + 2, 0, 0),*/new RedFly(this.x + 2, this.y + 4, 1, -1));
};

/////////////////////////////////////////
/////////BIG RED FLY FUNCTION////////////
/////////////////////////////////////////
var BigRedFly = function(x, y, velX, velY, alwaysChase) {
    this.x = x;
    this.y = y;
    this.w = 12;
    this.h = 5;
    this.ded = false;
    this.immuneTimers = [-10,-10];
    this.inWater = false;
    this.velX = 0;
    this.velY = 0;
    if (velX) {this.velX = velX;}
    if (velY) {this.velY = velY;}
    this.alwaysChase = alwaysChase;
    if (!this.alwaysChase) {this.alwaysChase = false;}
    this.hp = 3;
    this.sprite = "bigRedFly1";
    this.spriteTimer = 0;
    this.flyFrames = ["bigRedFly1","bigRedFly2"];
    this.dir = 1;
    if (random(0, 1) > 0.5) {this.dir = -1;}
    this.idleTimer = enemies.length * 50;
    while (this.idleTimer > 314) {
        this.idleTimer -= 314;
    }
    this.stretchCount = 0;

    this.target = 0;//By default, target player 1
    this.isChasing = false;
};

BigRedFly.prototype.run = function() {
    this.spriteTimer += 0.25;
    if (floor(this.spriteTimer) > 1) {
        this.spriteTimer = 0;
    }
    if (this.stretchCount > 0) {
        this.stretchCount -= 0.25;
    } 
    if (this.strechCount <= 0) {
        this.stretchCount = 0;
    }
    if (this.alwaysChase) {this.stretchCount = 0;}
    //Only update the velocities if the fly is within a certain distance of the player, otherwise stop
    if (dist(this.x + 6, this.y + 2, players[this.target].x + 7, players[this.target].y + 11) < 212 && this.isChasing && this.stretchCount <= 0 || this.alwaysChase) {
        //Update the x velocity
        if (players[this.target].x < this.x + this.w / 2) {
            this.velX -= 0.075 * (this.inWater ? 0.5 : 1);
        } else if (players[this.target].x > this.x + this.w / 2) {
            this.velX += 0.075 * (this.inWater ? 0.5 : 1);
        }
        //Update the y velocity
        if (players[this.target].y < this.y + this.h / 2) {
            this.velY -= 0.075 * (this.inWater ? 0.5 : 1);
        } else if (players[this.target].y > this.y + this.h / 2) {
            this.velY += 0.075 * (this.inWater ? 0.5 : 1);
        }
    } else if (dist(this.x + 6, this.y + 2, players[this.target].x + 7, players[this.target].y + 11) < 128 && this.stretchCount <= 0) {
        this.isChasing = true;
        this.idletimer = -10;
        if (!this.alwaysChase) {
            this.stretchCount = 2.5;
            playSound("redFlySurprised");
        }
    } else if (this.stretchCount <= 0 || !this.isChasing) {
        this.isChasing = false;
        if (abs(this.velX) < 0.1 && this.idleTimer < -10) {
            this.idleTimer = this.velX * 100;
            this.velX = 0;
        } else if (this.idleTimer >= 0) {
            this.idleTimer++;
            if (this.idleTimer > 314) {this.idleTimer = 0;}
            this.velX = cos(this.idleTimer / 25) / 7;
            this.velY = sin(this.idleTimer / 50) / 7;
        } else {
            this.velX /= 1.1;
        }
        if (abs(this.velY) < 0.1) {
            this.velY = 0;
        } else {
            this.velY /= 1.1;
        }
    }

    //constrain the x and y velocities
    this.velX = constrain(this.velX, -3, 3);
    this.velY = constrain(this.velY, -3, 3);
    if (this.inWater) {
        this.velX = constrain(this.velX, -2, 2);
        this.velY = constrain(this.velY, -2, 2);
    }

    if (this.kbTimer > 0) {
        if (this.kbDir == 1) {
            this.velX = this.kbTimer;
        } else if (this.kbDir == -1) {
            this.velX = -this.kbTimer;
        } else if (this.kbDir == "Down") {
            this.velY = this.kbTimer;
        } else if (this.kbDir == "Up") {
            this.velY = -this.kbTimer;
        }
    }

    //Move the fly
    this.x += this.velX;
    this.y += this.velY;

    if (this.hp > 0) {
        attackBox(this.x, this.y, this.w, this.h, this);
        if (this.hp > 0) {damageBox(this.x + 1, this.y + 1, this.w - 2, this.h - 1, 1);}
    } else {
        enemies.push(new corpse(this.x, this.y, this.w, this.h, this.kbDir, -2, this.dir, "bigRedFlyCorpse"));
        this.ded = true;
    }

    //COLLISION CODE
    this.inWater = false;
    checkCollisions(this);
    //COLLISION CODE

    if (this.velX < 0) {
        this.dir = -1;
    } else if (this.velX > 0) { 
        this.dir = 1;
    }

    this.sprite = this.flyFrames[floor(this.spriteTimer)];
};

BigRedFly.prototype.draw = function() {
    if (this.stretchCount < 0) {this.stretchCount = 0;}
    //Render the big red fly
    if (this.hp > 0 && checkBlinking(this)) {
        save();
        translate(this.x, this.y);
        if (this.dir < 0) {translate(this.w, 0);}
        scale(this.dir, 1);
        image("enemySprites", enemyImgs[this.sprite], -floor(this.stretchCount), -floor(this.stretchCount), enemyImgs[this.sprite].w + floor(this.stretchCount * 2), enemyImgs[this.sprite].h + floor(this.stretchCount * 2));
        restore();
    }
};


BigRedFly.prototype.takeDamage = function(amount, kb) {
    playSound("redFlyDamage" + floor(random(1, 3.9999)));
    this.hp -= amount;
    takeKb(this, kb);
};

BigRedFly.prototype.wallTop = function() {this.velY = 0;}
BigRedFly.prototype.wallLeft = function() {this.velX = 0;};
BigRedFly.prototype.wallRight = function() {this.velX = 0;};
BigRedFly.prototype.wallBottom = function() {this.velY = 0;};

/////////////////////////////////////////
///////RED PARASITE FUNCTION/////////////
/////////////////////////////////////////
var redParasite = function(x, y) {
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.hp = 2;
    this.x = x;
    this.y = y;
    this.w = 14;
    this.h = 11;
    this.dir = 1;
    this.velX = 1;
    this.speed = 1.5;
    this.velY = 0;
    this.sprite = "redParasite1";
    this.spriteTimer = 1;
    this.turnTimer = 0;
    this.waterTimer = 30 + sin(this.x) * 10;
};

redParasite.prototype.run = function() {
    if (!this.inWater) {
        this.spriteTimer += 0.25;
    } else {
        if (this.waterTimer < 20) {
            this.spriteTimer += 0.2;
        } else {
            this.spriteTimer = 1;
        }
    }
    if (floor(this.spriteTimer) > 5 || this.inWater && floor(this.spriteTimer) > 4) {this.spriteTimer = 1;}
    //Turn worm around if there is no ground in front of it
    if (this.groundCheck == false && this.turnTimer <= 0) {
        //this.dir = -this.dir;
        //this.x += this.dir;
        this.turnTimer = 6;
    }
    //Reset the groundCheck
    this.groundCheck = false;

    this.velY += 0.1;
    if (!this.inWater) {
        this.velX = this.dir * this.speed;
        this.waterTimer = 30 + sin(this.x) * 10;
    } else {
        this.waterTimer--; 
        if (this.waterTimer < 0) {
            this.waterTimer = 70;
            this.velX = this.dir * 3;
        }
        this.velX /= 1.04;
    }
    if (this.turnTimer > 0) {
        this.turnTimer--;
        this.velX = 0;
        this.spriteTimer = 1;
        if (this.turnTimer == 5) {
            this.dir = -this.dir;
        }
    }

    if (this.kbTimer > 0) {
        if (this.kbDir == 1) {
            this.velX = this.kbTimer;
        } else if (this.kbDir == -1) {
            this.velX = -this.kbTimer;
        } else {
            //this.velX = 0;
        }
    }

    this.x += this.velX;
    if (this.inWater) {this.velY = 0;}
    this.y += this.velY;
    this.inWater = !(currentLevel[currentLevel.length - 1][0].attributes.underWater != true);
    checkCollisions(this);
    if (this.inWater) {this.groundCheck = true;}
    if (this.hp > 0) {
        attackBox(this.x, this.y + 1, this.w, this.h - 3, this);
        if (this.hp > 0) {
            damageBox(this.x + 2, this.y + 3, this.w - 4, this.h - 8, 1);
            //fill(255, 0, 0);
            //rect(this.x + 2, this.y + 3, this.w - 4, this.h - 8);
        }
    } else {
        enemies.push(new corpse(this.x, this.y, this.w, this.h, this.kbDir, -2, this.dir, "redParasiteCorpse"));
        this.ded = true;
    }
    this.sprite = "redParasite" + floor(this.spriteTimer);
    if (this.inWater) {
        this.sprite = "redParasiteSwim" + floor(this.spriteTimer);
    }
};

redParasite.prototype.extraCheck = function(x, y, w, h) {
    //Check if there is block in front of beetle
    if (this.x + this.w * 2 > x && this.x + this.w < x + w && this.y + this.h + 0.2 > y && this.y - 0.2 < y + h && this.dir > 0
     || this.x > x && this.x - this.w < x + w && this.y + this.h + 0.2 > y && this.y - 0.2 < y + h && this.dir < 0) {
        this.groundCheck = true;
    }
};

redParasite.prototype.draw = function() {
    save();
    translate(round(this.x), round(this.y));
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], 0, 0);
    }
    restore();
};


redParasite.prototype.takeDamage = function(amount, kb) {
    playSound("redFlyDamage" + floor(random(1, 3.9999)));
    this.hp -= amount;
    takeKb(this, kb);
};

redParasite.prototype.wallTop = function() {this.velY = 0;};
redParasite.prototype.wallLeft = function() {
    //this.dir = -1;
    //this.groundCheck = true;
    this.turnTimer = 10;
    this.waterTimer = 7;
};
redParasite.prototype.wallRight = function() {
    //this.dir = 1;
    //this.groundCheck = true;
    this.turnTimer = 10;
    this.waterTimer = 8;
};
redParasite.prototype.wallBottom = function() {this.velY = 0;};

/////////////////////////////////////////
/////////RED FLY NEST FUNCTION///////////
/////////////////////////////////////////
var BigRedFlyNest = function(x, y) {
    this.x = x;
    this.y = y;
};


/////////////////////////////////////////
//////////////BAT FUNCTION///////////////
/////////////////////////////////////////
var Bat = function(x, y, sleep) {
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.x = x;
    this.y = y;
    this.w = 11;
    this.h = 8;
    this.velX = 0;
    this.velY = 0;
    this.dir = 1;
    this.hp = 2;
    this.ded = false;
    this.sleeping = 0;
    if (sleep[0] == "1") {
        this.sleeping = 1;
    } else if (sleep[3] == "1") {
        this.sleeping = 2;
    } else if (sleep[1] == "1") {
        this.sleeping = 3;
    }

    this.spriteTimer = 1;
    this.sprite = "batSleeping" + this.sleeping;
    if (this.sleeping == 0) {this.sprite = "bat1";}
    this.spriteDir = 1;
    this.target = 0;
};

Bat.prototype.run = function() {
    if (dist(this.x + 6, this.y + 2, players[this.target].x + 7, players[this.target].y + 11) < 112 && this.sleeping != 0) {
        this.sleeping = 0;
        playSound("batFlap");
    }
    if (dist(this.x + 6, this.y + 2, players[this.target].x + 7, players[this.target].y + 11) < (212 / (players[this.target].inWater ? 2 : 1)) && this.sleeping == 0) {
        if (players[this.target].x < this.x) {
            this.velX -= 0.1;
            this.dir = -1;
        } else if (players[this.target].x > this.x) {
            this.velX += 0.1;
            this.dir = 1;
        }

        if (players[this.target].y < this.y) {
            this.velY -= 0.1;
        } else if (players[this.target].y > this.y) {
            this.velY += 0.1;
        }
    } else {
        if (abs(this.velX) < 0.1) {
            this.velX = 0;
        } else {
            this.velX /= 1.1;
        }
        if (abs(this.velY) < 0.1) {
            this.velY = 0;
        } else {
            this.velY /= 1.1;
        }
    }

    this.velX = constrain(this.velX, -1.6, 1.6);
    this.velY = constrain(this.velY, -1.6, 1.6);


    if (this.kbTimer > 0) {
        if (this.kbDir == 1) {
            this.velX = this.kbTimer;
        } else if (this.kbDir == -1) {
            this.velX = -this.kbTimer;
        } else if (this.kbDir == "Down") {
            this.velY = this.kbTimer;
        } else if (this.kbDir == "Up") {
            this.velY = -this.kbTimer;
        }
    }
    if (this.inWater) {this.velY = -this.velY;}
    this.x += this.velX;
    this.y += this.velY;

    //COLLISION CHECK
    this.inWater = false;
    checkCollisions(this);
    //COLLISION CHECK
    if (this.hp > 0) {
        attackBox(this.x, this.y, this.w, this.h, this);
        if (this.hp > 0) {
            damageBox(this.x + 1, this.y + 1, this.w - 2, this.h - 2, 1);
        }
    } else {
        enemies.push(new corpse(this.x, this.y - 1, this.w, this.h, this.kbDir, -2, this.dir, "batCorpse"));
        this.ded = true;
    }

    this.spriteTimer += this.spriteDir * 0.5;
    if (this.spriteTimer >= 6) {
        this.spriteDir = -1;
        this.spriteTimer += this.spriteDir * 0.5;
    } else if (this.spriteTimer <= 1) {
        this.spriteDir = 1;
        this.spriteTimer += this.spriteDir * 0.5;
    }
    this.sprite = "bat" + floor(this.spriteTimer);
    if (this.sleeping > 0) {
        this.sprite = "batSleeping" + this.sleeping;
    }
};

Bat.prototype.draw = function() {
    save();
    translate(this.x, this.y);
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], 0, 0);
    }
    restore();
    fill(255, 0, 0);
    //rect(round(this.x), round(this.y), this.w, this.h);
};

Bat.prototype.takeDamage = function(amount, kb) {
    playSound("batDamage");
    this.hp -= amount;
    takeKb(this, kb);
};

Bat.prototype.wallTop = function() {this.velY = 0;};
Bat.prototype.wallLeft = function() {this.velX = 0;};
Bat.prototype.wallRight = function() {this.velX = 0;};
Bat.prototype.wallBottom = function() {this.velY = 0;};


/////////////////////////////////////////
/////////////BEETLE FUNCTION/////////////
/////////////////////////////////////////
var pancakeBeetle = function(x, y) {
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.hp = 2;
    this.x = x;
    this.y = y;
    this.w = 16;
    this.h = 11;
    this.dir = 1;
    this.velX = 1;
    this.speed = 1.5;
    this.velY = 0;
    this.sprite = "pancakeBeetle1";
    this.spriteTimer = 1;
    this.turnTimer = 0;
};

pancakeBeetle.prototype.run = function() {
    this.spriteTimer += 0.3;
    if (floor(this.spriteTimer) > 5) {this.spriteTimer = 1;}
    //Turn worm around if there is no ground in front of it
    if (this.groundCheck == false && this.turnTimer <= 0) {
        //this.dir = -this.dir;
        //this.x += this.dir;
        this.turnTimer = 10;
    }
    //Reset the groundCheck
    this.groundCheck = false;

    this.velY += 0.1;
    this.velX = this.dir * this.speed;
    if (this.turnTimer > 0) {
        this.turnTimer--;
        this.velX = 0;
        this.spriteTimer = 2;
        if (this.turnTimer == 5) {
            this.dir = -this.dir;
        }
    }

    if (this.kbTimer > 0) {
        if (this.kbDir == 1) {
            this.velX = this.kbTimer;
        } else if (this.kbDir == -1) {
            this.velX = -this.kbTimer;
        } else {
            //this.velX = 0;
        }
    }

    this.x += this.velX;
    this.y += this.velY;
    checkCollisions(this);
    if (this.hp > 0) {
        attackBox(this.x, this.y + 1, this.w, this.h - 1, this);
        if (this.hp > 0) {
            damageBox(this.x + 1, this.y + 2, this.w - 2, this.h - 3, 1);
        }
    } else {
        this.ded = true;
        enemies.push(new corpse(this.x, this.y, this.w, this.h, this.kbDir, -2, this.dir, "pancakeBeetleCorpse"));
    }
    this.sprite = "pancakeBeetle" + floor(this.spriteTimer);
};

pancakeBeetle.prototype.extraCheck = function(x, y, w, h) {
    //Check if there is block in front of beetle
    if (this.x + this.w * 2 > x && this.x + this.w < x + w && this.y + this.h + 0.2 > y && this.y - 0.2 < y + h && this.dir > 0
     || this.x > x && this.x - this.w < x + w && this.y + this.h + 0.2 > y && this.y - 0.2 < y + h && this.dir < 0) {
        this.groundCheck = true;
    }
};

pancakeBeetle.prototype.draw = function() {
    save();
    translate(round(this.x), round(this.y));
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], 0, 0);
    }
    restore();
};


pancakeBeetle.prototype.takeDamage = function(amount, kb) {
    this.hp -= amount;
    takeKb(this, kb);
    playSound("pancakeBeetleHurt" + round(random(1, 2)), 0.6);
};

pancakeBeetle.prototype.wallTop = function() {this.velY = 0;};
pancakeBeetle.prototype.wallLeft = function() {
    //this.dir = -1;
    //this.groundCheck = true;
    this.turnTimer = 10;
};
pancakeBeetle.prototype.wallRight = function() {
    //this.dir = 1;
    //this.groundCheck = true;
    this.turnTimer = 10;
};
pancakeBeetle.prototype.wallBottom = function() {this.velY = 0;};


/////////////////////////////////////////
////////////ELECTRIC SHOT////////////////
/////////////////////////////////////////
var electricShot = function(x, y, dir) {
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.hp = 6;
    this.x = x;
    this.y = y;
    this.w = 6;
    this.h = 6;
    this.dir = dir;
    this.velX = dir * 2;
    this.velY = 0;
    this.sprite = "electricShot1";
    this.spriteTimer = 1;
    this.ded = false;
};
electricShot.prototype.run = function() {
    this.x += this.velX;
    this.y += this.velY;
    checkCollisions(this);
    if (!this.ded) {
        damageBox(this.x + 2, this.y + 2, this.w - 4, this.h - 4, 2);
    }
    this.spriteTimer += 0.25;
    if (floor(this.spriteTimer) >= 6) {this.spriteTimer = 1;}
    this.sprite = "electricShot" + floor(this.spriteTimer);
};
electricShot.prototype.draw = function() {
    image("enemySprites", enemyImgs[this.sprite], this.x, this.y);
};
electricShot.prototype.wallLeft = function() {this.ded = true;};
electricShot.prototype.wallRight = function() {this.ded = true;};
electricShot.prototype.wallTop = function() {this.ded = true;};
electricShot.prototype.wallBottom = function() {this.ded = true;};
/////////////////////////////////////////
//////MALFUNCTIONING PERSON//////////////
/////////////////////////////////////////
var malfunctioningPerson = function(x, y) {
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.hp = 6;
    this.x = x;
    this.y = y;
    this.w = 14;
    this.h = 23;
    this.dir = 1;
    this.velX = 0;
    this.velY = 0;
    //spriteTimer = weird thing with head, walkTimer = walking animation
    this.spriteTimer = 1;
    this.walkTimer = 1;
    this.sprite = "malfunctioningPersonIdle1";
    this.ded = false;
    this.attackTimer = 0;
    this.attackType = 0;
    this.target = 0;
    this.isGrounded = true;
    this.isChasing = false;
    this.attackAttempts = 0;
};

malfunctioningPerson.prototype.run = function() {
    if (this.attackTimer > -10) {
        this.attackTimer -= 1;
    }
    if (this.attackTimer < -5) {
        if (checkPlayers(this.x + this.w / 2 + ((this.dir == 1) ? 8 : -72), this.y - 24, 64, this.h + 24) && this.isGrounded > 0 && this.attackTimer < -8) {
            this.attackType = round(random(0, 1) - this.attackAttempts);
            this.attackTimer = 65;
            this.isChasing = true;
        } else if (players[this.target].x + players[this.target].w / 2 < this.x + this.w / 2 && this.isChasing && this.isGrounded > 0) {
            this.dir = -1;
            this.velX = -1;
        } else if (players[this.target].x + players[this.target].w / 2 > this.x + this.w / 2 && this.isChasing && this.isGrounded > 0) {
            this.dir = 1;
            this.velX = 1;
        } else if (this.isChasing) {
            this.velX = this.dir;
        }
        //rect(this.x + this.w / 2 + ((this.dir == 1) ? 8 : -72), this.y - 24, 64, this.h + 24);
    }
    if (this.spriteTimer < 2) {
        this.spriteTimer += 0.0025;
    } else {
        this.spriteTimer += 0.2;
    }
    if (this.spriteTimer >= 6) {
        this.spriteTimer = 1;
    }
    if (this.attackTimer <= 0) {
        if (this.velX == 0) {
            this.sprite = "malfunctioningPersonIdle" + floor(this.spriteTimer);
            if (this.spriteTimer > 1.01 && this.spriteTimer < 1.02 || this.spriteTimer > 1.07 && this.spriteTimer < 1.08 ||
                this.spriteTimer > 1.61 && this.spriteTimer < 1.62 || this.spriteTimer > 1.67 && this.spriteTimer < 1.68) {
                this.sprite = "malfunctioningPersonIdle6";
            }
            for (var i = 0; i < players.length; i++) {
                if (dist(players[i].x + players[i].w / 2, players[i].y + players[i].h / 2,
                         this.x + this.w / 2, this.y + this.h / 2) < 150) {
                    this.target = i;
                    this.isChasing = true;
                }
            }
        } else {
            this.spriteTimer = 1;
            this.walkTimer += 0.25;
            //this.dir = ((players[this.target].x + 7 < this.x + 7) ? -1 : 1);
            if (floor(this.walkTimer) > 4) {this.walkTimer = 0;}
            this.sprite = "malfunctioningPersonWalk" + [1,2,3,4,5][floor(this.walkTimer)];
        }
    } else if (this.attackType == 0) {
        this.attackAttempts = 0;
        this.spriteTimer = 1;
        this.walkTimer = 1;
        if (this.attackTimer == 55) {
            playSound("malfuncAttack");
        }
        if (this.attackTimer > 20 && this.attackTimer <= 25) {
            this.velX = this.dir * (this.attackTimer - 15);
        }
        this.sprite = "malfunctioningPersonAttack" + [1,2,3,4,4,4,5,4,6,7,8,8,9][constrain(floor((65 - this.attackTimer) / 5), 0, 12)];
    } else {
        this.attackAttempts += 0.25;
        if (this.attackTimer > 60) {
            this.velY = -4.5;
            this.attackTimer = 55;
            playSound("playerJump");
        }
        this.velX = this.dir * 1;
        if (this.isGrounded > 0) {
            this.attackTimer = -1;
        }
    }
    this.velY += 0.3;
    if (this.kbTimer > 0) {
        if (this.kbDir == 1) {
            this.velX += this.kbTimer * 0.75;
        } else if (this.kbDir == -1) {
            this.velX += -this.kbTimer * 0.75;
        }
    }
    this.x += this.velX;
    this.y += this.velY;
    this.isGrounded--;
    checkCollisions(this);
    if (this.hp > 0) {
        attackBox(this.x, this.y, this.w, this.h, this);
        if (this.hp > 0) {
            damageBox(this.x, this.y, this.w, this.h, 1);
            if (this.attackType == 0 && this.attackTimer > 20 && this.attackTimer < 25) {
                damageBox(this.x + this.w / 2 + ((this.dir == 1) ? 0 : -26), this.y, 26, this.h, 1);
            }
        }
    } else {
        this.ded = true;
        enemies.push(new malfunctioningCorpse(this.x, this.y, this.w, this.h, this.kbDir, -2, this.dir, "malfunctioningPersonCorpse1"));
    }
    this.velX = 0;
    if (this.isGrounded < 0 && this.attackTimer < 20 | this.attackTimer > 25) {
        if (this.velY < -1) {
            this.sprite = "malfunctioningPersonJump1";
        } else if (this.velY >= -1 && this.velY < 0) {
            this.sprite = "malfunctioningPersonJump2";
        } else if (this.velY >= 0 && this.velY < 1) {
            this.sprite = "malfunctioningPersonJump3";
        } else if (this.velY >= 1 && this.velY < 2) {
            this.sprite = "malfunctioningPersonJump4";
        } else if (this.velY >= 2) {
            this.sprite = "malfunctioningPersonJump5";
        }
    }
};
malfunctioningPerson.prototype.draw = function() {
    save();
    translate(round(this.x), round(this.y));
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], -1, 0);
    }
    restore();
};

malfunctioningPerson.prototype.wallLeft = function() {
    if (this.isGrounded > 0 && this.attackTimer < -5) {
        this.velY = -6.3;
        this.isGrounded = -1;
    }
};
malfunctioningPerson.prototype.wallRight = function() {
    if (this.isGrounded > 0 && this.attackTimer < -5) {
        this.velY = -6.3;
        this.isGrounded = -1;
    }
};
malfunctioningPerson.prototype.wallTop = function() {
    this.velY = 0;
    this.isGrounded = 5;
};
malfunctioningPerson.prototype.wallBottom = function() {
    this.velY = 1;
    this.isGrounded = -1;
};

malfunctioningPerson.prototype.takeDamage = function(amount, kb) {
    playSound("malfuncDamage");
    this.hp -= amount;
    takeKb(this, kb);
};

/////////////////////////////////////////
//////MALFUNCTIONING ROBOT///////////////
/////////////////////////////////////////
var malfunctioningRobot = function(x, y) {
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.hp = 12;
    this.x = x;
    this.y = y;
    this.w = 15;
    this.h = 30;
    this.dir = 1;
    this.velX = 0;
    this.velY = 0;
    //spriteTimer = weird thing with head, walkTimer = walking animation
    this.spriteTimer = 1;
    this.walkTimer = 1;
    this.sprite = "malfunctioningRobotIdle1";
    this.ded = false;
    this.attackTimer = 0;
    this.attackType = 0;
    this.target = 0;
    this.isGrounded = true;
    this.isChasing = false;
    this.attackAttempts = 0;
    this.shootTimer = 0;
    this.hasLanded = false;
    this.wallXs = [];
};

malfunctioningRobot.prototype.run = function() {
    //if (abs(players[this.target].x - this.x) > 256 || players[this.target].y < this.y - 256) {this.isChasing = false;}
    if (this.attackTimer > -10) {
        this.attackTimer -= 1;
    }
    if (this.shootTimer > 0) {
        this.shootTimer--;
    }
    if (!this.isGrounded && this.attackTimer < -5) {
        this.attackType = 0;
        this.attackTimer = 30;
    }
    if (this.attackTimer < -5) {
        //checkPlayers(this.x + this.w / 2 + ((this.dir == 1) ? 8 : -72), this.y - 24, 64, this.h + 24)
        if (checkPlayers(this.x + this.w / 2 - 72, this.y - 24, 128, this.h + 24) && this.isGrounded > 0 && this.attackTimer < -8) {
            this.attackType = round(random(0, 1) - this.attackAttempts);
            this.attackTimer = 65;
            this.isChasing = true;
            this.wallXs = [];
            this.walkTimer = 1;
        } else if (players[this.target].x + players[this.target].w / 2 < this.x + this.w / 2 && this.isChasing) {
            this.velX = -1.6;
        } else if (players[this.target].x + players[this.target].w / 2 > this.x + this.w / 2 && this.isChasing) {
            this.velX = 1.6;
        }
    }
    if (this.attackTimer <= 0) {
        if (this.velX != 0) {
            this.spriteTimer = 1;
            this.walkTimer += 0.5;
            this.dir = ((players[this.target].x + 7 < this.x + 7) ? -1 : 1);
            if (floor(this.walkTimer) > 7) {this.walkTimer = 1;}
            this.sprite = "malfunctioningRobotWalk" + floor(this.walkTimer);
        } else {
            this.sprite = "malfunctioningRobotIdle1";
        }
    } else if (this.attackType == 0) {
        if (this.attackTimer > 45 && this.isGrounded) {
            if (this.attackTimer == 59) {playSound("robotJump");}
            this.spriteTimer += 0.1;
            this.sprite = "malfunctioningRobotJump" + (5 - ceil(constrain((this.attackTimer - 45) / 5, 1, 4)));
        } else if (this.attackTimer <= 45 && this.attackTimer >= 35 && this.isGrounded) {
            this.isGrounded = false;
            this.velY = -5.6;
        } else if (!this.isGrounded) {
            this.attackTimer = 17;
            this.spriteTimer = 1;
            this.velX = this.dir / 2;
            this.sprite = "malfunctioningRobotJump4";
        } else if (this.hasLanded && this.isGrounded && this.attackTimer <= 16) {
            if (this.attackTimer == 15) {
                enemies.push(new electricShot(this.x, this.y + this.h - 10, -2),
                             new electricShot(this.x + this.w - 10, this.y + this.h - 10, 2));
                playSound("robotLand");
            }
            this.spriteTimer += 0.1;
            this.sprite = "malfunctioningRobotLand" + (5 - ceil(constrain((this.attackTimer) / 5, 1, 4)));
        }
    } else if (this.attackType == 1) {
        if (this.attackTimer == 50) {playSound("robotAttack");}
        this.spriteTimer = 1;
        this.sprite = "malfunctioningRobotAttack" + (constrain(ceil((65 - this.attackTimer) / 5), 1, 13));
        if (constrain(ceil((65 - this.attackTimer) / 5)) >= 9 && constrain(ceil((65 - this.attackTimer) / 5)) <= 10) {
            this.attackTimer--;
        }
        if (this.attackTimer > 11 && this.attackTimer < 15) {
                this.attackTimer += 0.8;
                if (this.shootTimer <= 0) {
                    this.shootTimer = 3;
                    enemies.push(new electricShot(this.x + this.w / 2 + this.dir * this.w / 2, this.y + this.h - 10, this.dir * 2));
                }
        }
    }
    this.velY += 0.3;
    this.x += this.velX;
    this.y += this.velY;
    this.isGrounded = false;
    checkCollisions(this);
    if (this.isGrounded && !this.hasLanded) {
        this.hasLanded = true;
        this.attackTimer = -5;
    }
    if (this.hp > 0) {
        if (this.hp > 0 && this.attackType == 1 && this.attackTimer > 0 && constrain(ceil((65 - this.attackTimer) / 5)) > 9) {
            attackBox(this.x + 1, this.y + 17, this.w - 2, this.h - 8, this);
            attackBox(this.x + 3, this.y + 10, this.w - 6, 8, this);
            damageBox(this.x + 2, this.y + 16, this.w - 4, this.h - 16, 2);
            damageBox(this.x + 4, this.y + 9, this.w - 8, 7, 2);
        } else if (this.hp > 0) {
            attackBox(this.x + 1, this.y + 8, this.w - 2, this.h - 8, this);
            attackBox(this.x + 3, this.y + 1, this.w - 6, 8, this);
            damageBox(this.x + 2, this.y + 9, this.w - 4, this.h - 9, 2);
            if (this.attackTimer > 16 && this.attackTimer < 45 || this.attackType != 0) {
                damageBox(this.x + 4, this.y + 2, this.w - 8, 7, 2);
            }
        }
    } else {
        this.ded = true;
        enemies.push(new corpse(this.x - 1, this.y, 14, 10, random(-2, 2), -2, this.dir, "malfunctioningRobotHead", "enemySprites", enemyImgs, true),
                     new corpse(this.x - 1, this.y + 9, 13, 12, random(-2, 2), -1, this.dir, "malfunctioningRobotBody", "enemySprites", enemyImgs, true),
                     new corpse(this.x - 6, this.y + 9, 5, 10, random(-2, 2), -3, this.dir, "malfunctioningRobotArm", "enemySprites", enemyImgs, true),
                     new corpse(this.x + 12, this.y + 9, 5, 10, random(-2, 2), -3, this.dir, "malfunctioningRobotArm", "enemySprites", enemyImgs, true),
                     new corpse(this.x - 2, this.y + 21, 8, 9, random(-2, 2), -1, this.dir, "malfunctioningRobotLeg", "enemySprites", enemyImgs, true),
                     new corpse(this.x + 6, this.y + 21, 8, 9, random(-2, 2), -1, this.dir, "malfunctioningRobotLeg", "enemySprites", enemyImgs, true),);
    }
    this.velX = 0;
};
malfunctioningRobot.prototype.draw = function() {
    save();
    translate(round(this.x), round(this.y));
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], -1, 0);
    }
    restore();
};

malfunctioningRobot.prototype.wallLeft = function() {
    if (this.attackTimer < -4) {
        if (this.wallXs[0] != floor(this.x)) {this.wallXs = [];}
        if (this.wallXs.length < 3) {
            this.attackType = 0;
            this.attackTimer = 65;
            this.wallXs.push(floor(this.x));
        } else {
            this.isChasing = false;
        }
    }
};
malfunctioningRobot.prototype.wallRight = function() {
    if (this.attackTimer < -4) {
        if (this.wallXs[0] != floor(this.x)) {this.wallXs = [];}
        if (this.wallXs.length < 3) {
            this.attackType = 0;
            this.attackTimer = 65;
            this.wallXs.push(floor(this.x));
        } else {
            this.isChasing = false;
        }
    }
};
malfunctioningRobot.prototype.wallTop = function() {
    this.velY = 0;
    this.isGrounded = 5;
};
malfunctioningRobot.prototype.wallBottom = function() {
    this.velY = 1;
    this.isGrounded = -1;
};

malfunctioningRobot.prototype.takeDamage = function(amount, kb) {
    this.hp -= amount;
    playSound("robotDamage");
};



/////////////////////////////////////////
/////////SLEEP DROPPER PELLETS///////////
/////////////////////////////////////////
var sleepDropperPellet = function(x, y, velX, velY) {
    this.ded = false;
    //The Defaults
    this.x = x;
    this.y = y;
    this.w = 3;
    this.h = 3;
    this.velX = velX;
    this.velY = velY;
    this.sprite = "sleepDropperPellet";
    this.hp = 100;
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.spriteTimer = 0;
};
sleepDropperPellet.prototype.run = function() {
    this.velY += 0.1;
    this.x += this.velX;
    this.y += this.velY;
    checkCollisions(this);
    this.spriteTimer++;
    if (floor(this.spriteTimer) > 500) {
        this.spriteTimer = 500;
        this.ded = true;
    }
    if (!this.ded) {
        damageBox(this.x + 1, this.y + 1, this.w - 2, this.h - 2, 1);
    }
};
sleepDropperPellet.prototype.draw = function() {
    //Render the big red fly
    if (this.hp > 0 && checkBlinking(this)) {
        save();
        translate(this.x, this.y);
        if (this.dir < 0) {translate(this.w, 0);}
        scale(this.dir, 1);
        image("enemySprites", enemyImgs[this.sprite], 0, 0);
        restore();
    }
};

sleepDropperPellet.prototype.wallTop = function() {this.ded = true;};
sleepDropperPellet.prototype.wallLeft = function() {this.ded = true;};
sleepDropperPellet.prototype.wallRight = function() {this.ded = true;};




/////////////////////////////////////////
///////SLEEP DROPPER FUNCTION/////////////
/////////////////////////////////////////
var sleepDropper = function(x, y, isWalled) {
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.hp = 1;
    this.x = x;
    this.y = y;
    this.w = 16;
    this.h = 16;
    this.dir = 1;
    this.velX = 0;
    this.velY = 0;
    this.sprite = "sleepDropper1";
    this.spriteTimer = 1;
    this.fallH = 16;
    this.isWalled = 0;
    if (isWalled[1] == "1") {
        this.isWalled = -1;
        this.sprite = "sleepDropper2";
    }
    if (isWalled[3] == "1") {
        this.isWalled = 1;
        this.sprite = "sleepDropper2";
    }
    for (var i = floor(this.y / 16) + 1; i < currentLevel.length - 1; i++) {
        if (currentLevel[i][floor(this.x / 16)] != "-" && currentLevel[i][floor(this.x / 16)] != "8") {
            i = currentLevel.length;
        } else {
            this.fallH += 16;
        }
    }
    this.attackTimer = 0;
    this.shakeTimer = 0;
    this.soundType = 0;

    this.shakeTimer = 0;
    this.shakeOnX = 0;
};

sleepDropper.prototype.run = function() {
    if (this.attackTimer > -100) {
        this.attackTimer--;
    } else {
        this.soundType = 0;
    }
    if (-scrollY < this.y && this.attackTimer <= 0) {
        for (var i = 0; i < players.length; i++) {
            if (players[i].x + players[i].w > this.x - 32 + this.isWalled * 16 && players[i].x < this.x + this.w + 32 + this.isWalled * 16 && players[i].y > this.y && players[i].y < this.y + this.fallH) {
                this.attackTimer = 20;
                playSound("sleepDropperShoot" + [1,2,1,3,1,2,1,4][this.soundType], 0.6);
                this.soundType++;
                if (this.soundType > 7) {
                    this.soundType = 0;
                }
                for (var i = 0; i < 1; i++) {
                    enemies.push(new sleepDropperPellet(this.x + this.w / 2, this.y + this.h / 2, random(-1 + this.isWalled, 1 + this.isWalled), random(-2, -1.5), round(random(1, 2))));
                }
                this.shakeTimer = 3;
            }
        }
    }
    if (this.hp > 0) {
        attackBox(this.x, this.y + 3, this.w, this.h - 6, this);
        attackBox(this.x + 4, this.y + 10, this.w - 8, 7, this);
        if (this.hp > 0) {
            damageBox(this.x + 4, this.y + 5, this.w - 8, this.h - 9, 1);
            fill(255, 0, 0);
            rect(this.x + 4, this.y + 5, this.w - 8, this.h - 9);
        }
    } else {
        this.ded = true;
    }
    if (this.isWalled == 0) {
        this.sprite = "sleepDropper1";
    } else {
        this.sprite = "sleepDropper2";
    }
    if (this.shakeTimer > 0) {
        this.shakeTimer--;
        this.shakeOnX = random(-2, 2);
    } else {
        this.shakeOnX = 0;
    }
};

sleepDropper.prototype.draw = function() {
    save();
    translate(round(this.x + this.shakeOnX), round(this.y));
    if (this.isWalled < 0) {
        translate(this.w, 0);
        scale(-1, 1);
    }
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], 0, 0);
    }
    restore();
};


sleepDropper.prototype.takeDamage = function(amount, kb) {
    playSound("sleepDropperShoot1", 0.6);
    playSound("sleepDropperShoot2", 0.6);
    playSound("sleepDropperShoot3", 0.6);
    playSound("sleepDropperShoot4", 0.6);
    for (var i = 0; i < 4; i++) {
        enemies.push(new sleepDropperPellet(this.x + this.w / 2, this.y + this.h / 2, random(-1, 1), random(-2, -1.5), round(random(1, 2))));
    }
    this.hp -= amount;
    takeKb(this, kb);
};


/////////////////////////////////////////
////////SLEEP FROG SPIT FUNCTION/////////
/////////////////////////////////////////
var sleepFrogSpit = function(x, y, velX, velY) {
    this.x = x;
    this.y = y;
    this.w = 6;
    this.h = 6;
    this.velX = velX;
    this.velY = velY;
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.aliveTimer = 240;
    this.sprite = "sleepFrogSpitAir1";
    this.spriteTimer = 1;
    this.spriteCycle = 0;
    this.ded = false;
    this.dir = (random(0, 1) > 0.5) ? -1 : 1;
};
sleepFrogSpit.prototype.run = function() {
    if (this.h == 6) {
        this.velY += 0.1;
    } else {
        this.aliveTimer--;
    }
    if (this.aliveTimer > 30) {
        hurtBox(this.x + 1, this.y + 1, this.h - 2, this.w - 2, 1);
    } else if (this.aliveTimer <= 0) {
        this.ded = true;
    }
    if (this.aliveTimer > 30) {
        this.x += this.velX;
        this.y += this.velY;
        checkCollisions(this);
    } else {
        this.y += 0.5;
    }
    this.spriteTimer += 0.25;
    if (this.spriteTimer >= 4) {
        this.spriteTimer = 1;
    }
    if (this.h == 6) {
        this.sprite = "sleepFrogSpitAir" + floor(this.spriteTimer);
    } else {
        this.sprite = "sleepFrogSpitGround" + floor(this.spriteTimer);
    }
    this.spriteCycle++;
    if (this.spriteCycle > 1) {
        this.spriteCycle = 0;
    }
};
sleepFrogSpit.prototype.draw = function() {
    save();
    translate(round(this.x), round(this.y));
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    //fill(255, 255, 255);
    //rect(0, 0, this.w, this.h);
    image("enemySprites", enemyImgs[this.sprite], 0, 0);
    restore();
};
sleepFrogSpit.prototype.wallTop = function() {
    if (this.w != 8) {playSound("redFlyBossSpitLand", 0.25);}
    this.velY = 0;
    this.velX = 0;
    this.w = 8;
    this.h = 3;
    this.x -= 2;
    this.y += 3;
};


/////////////////////////////////////////
/////////SLEEP FROG FUNCTION/////////////
/////////////////////////////////////////
var sleepFrog = function(x, y) {
    this.immuneTimers = [-10, -10];
    this.inWater = false;
    this.hp = 4;
    this.x = x;
    this.y = y;
    this.w = 15;
    this.h = 9;
    this.target = 0;
    this.dir = this.dir = ((players[this.target].x + 7 < this.x + this.w / 2) ? -1 : 1);;
    this.velX = 0;
    this.speed = 1.5;
    this.velY = 0;
    this.sprite = "sleepFrogIdle1";
    this.spriteTimer = 1;
    this.jumpTimer = -1;
    this.waterTimer = 30 + sin(this.x) * 10;
    this.onGround = false;
    this.playerNear = false;
    this.sleeping = true;
    this.sleepTimer = 1;
    this.sleepTimerDir = 0.015;
    this.attack = round(random(0, 1));
};

sleepFrog.prototype.run = function() {
    for (var i = 0; i < players.length; i++) {
        if (dist(players[i].x + players[i].w / 2, players[i].y + players[i].h / 2,
                 this.x + this.w / 2, this.y + this.h / 2) < 150) {
            this.playerNear = true;
        } else if (this.onGround && dist(players[i].x + players[i].w / 2, players[i].y + players[i].h / 2,
                 this.x + this.w / 2, this.y + this.h / 2) > 250) {
            this.playerNear = false;
        }
    }
    this.velY += 0.1;
    if (!this.inWater) {
        //this.velX = this.dir * this.speed;
        this.waterTimer = 30 + sin(this.x) * 10;
    }
    if (this.sleeping) {this.jumpTimer = -1;}
    if (!this.onGround) {
        this.jumpTimer = -1;
    } else {
        this.velX = 0;
        if (this.jumpTimer == 20) {
            this.attack = random(0, 1);
        }
        if (this.jumpTimer < 65 && !this.sleeping && this.attack < 0.6) {
            this.dir = ((players[this.target].x + 7 < this.x + this.w / 2) ? -1 : 1);
        }
    }
    if (this.jumpTimer >= 0) {
        this.jumpTimer++;
        if (this.onGround) {
            if (this.attack < 0.6 && this.jumpTimer > 100) {
                this.velY = random(-3.5, -2.5);
                playSound("sleepFrogJump", 0.65);
                this.velX = this.dir * random(1, 1.5);
                this.jumpTimer = -1;
                this.attack = 0;
            } else if (this.attack >= 0.6 && this.jumpTimer == 71 | this.jumpTimer == 86) {
                playSound("sleepFrogSpit", 0.4);
                enemies.push(new sleepFrogSpit(this.x + this.w / 2 - 2, this.y + 1, this.dir * 2, random(-2, -1)));
            } else if (this.attack >= 0.6 && this.jumpTimer > 100) {
                this.jumpTimer = -1;
                this.attack = 0;
            }
        }
    }

    if (this.kbTimer > 0) {
        if (this.kbDir == 1) {
            this.velX = this.kbTimer;
        } else if (this.kbDir == -1) {
            this.velX = -this.kbTimer;
        } else {
            //this.velX = 0;
        }
    }

    this.x += this.velX;
    this.y += this.velY;
    this.inWater = !(currentLevel[currentLevel.length - 1][0].attributes.underWater != true);
    this.onGround = false;
    checkCollisions(this);
    if (this.inWater) {this.groundCheck = true;}
    if (this.hp > 0) {
        attackBox(this.x, this.y, this.w, this.h - 3, this);
        if (this.hp > 0) {
            damageBox(this.x + 2, this.y + 3, this.w - 4, this.h - 8, 1);
        }
    } else {
        enemies.push(new corpse(this.x, this.y, this.w, this.h, this.kbDir, -2, this.dir, "sleepFrogCorpse"));
        this.ded = true;
    }
    this.sprite = "sleepFrogIdle1";
    if (this.jumpTimer > 75 && this.attack < 0.6) {
        this.sprite = "sleepFrogJump2";
    } else if (this.jumpTimer > 65 && this.attack < 0.6) {
        this.sprite = "sleepFrogJump1";
    } else if (this.jumpTimer > 95 && this.attack >= 0.6) {
        this.sprite = "sleepFrogSpit1";
    } else if (this.jumpTimer > 90 && this.attack >= 0.6) {
        this.sprite = "sleepFrogSpit2";
    } else if (this.jumpTimer > 85 && this.attack >= 0.6) {
        this.sprite = "sleepFrogSpit3";
    } else if (this.jumpTimer > 75 && this.attack >= 0.6) {
        this.sprite = "sleepFrogSpit2";
    } else if (this.jumpTimer > 70 && this.attack >= 0.6) {
        this.sprite = "sleepFrogSpit3";
    } else if (this.jumpTimer > 65 && this.attack >= 0.6) {
        this.sprite = "sleepFrogSpit2";
    } else if (this.jumpTimer > 60 && this.attack >= 0.6) {
        this.sprite = "sleepFrogSpit1";
    } else if (this.jumpTimer > 55 && this.attack >= 0.6) {
        this.sprite = "sleepFrogChew2";
    } else if (this.jumpTimer > 50 && this.attack >= 0.6) {
        this.sprite = "sleepFrogChew1";
    } else if (this.jumpTimer > 45 && this.attack >= 0.6) {
        this.sprite = "sleepFrogChew3";
    } else if (this.jumpTimer > 40 && this.attack >= 0.6) {
        this.sprite = "sleepFrogChew2";
    } else if (this.jumpTimer > 35 && this.attack >= 0.6) {
        this.sprite = "sleepFrogChew1";
    } else if (this.jumpTimer > 30 && this.attack >= 0.6) {
        this.sprite = "sleepFrogChew3";
    } else if (this.jumpTimer > 25 && this.attack >= 0.6) {
        this.sprite = "sleepFrogChew2";
    } else if (this.jumpTimer > 20 && this.attack >= 0.6) {
        this.sprite = "sleepFrogChew1";
    } else if (!this.onGround) {
        if (this.velY < -0.5) {
            this.sprite = "sleepFrogJump3";
        } else if (this.velY < 0) {
            this.sprite = "sleepFrogJump4";
        } else if (this.velY < 0.5) {
            this.sprite = "sleepFrogJump5";
        } else if (this.velY < 1) {
            this.sprite = "sleepFrogJump6";
        } else {
            this.sprite = "sleepFrogJump7";
        }
    }
    if (this.sleeping) {
        this.sleepTimer += this.sleepTimerDir;
        if (this.playerNear) {
            this.sleepTimerDir = 0.2;
        }
        if (this.sleepTimer < 1) {
            this.sleepTimer = 1;
            this.sleepTimerDir = 0.015;
        } if (this.sleepTimer >= 3 && !this.playerNear && this.sleepTimerDir > 0) {
            this.sleepTimer = 2;
            this.sleepTimerDir = -0.015;
        } else if (this.sleepTimer >= 5 && this.playerNear && this.sleepTimerDir > 0) {
            this.sleepTimer = 4;
            this.sleeping = false;
        }
        this.sprite = "sleepFrogSleep" + floor(this.sleepTimer);
    } else {
        //this.sleepTimer = 1;
        if (!this.playerNear && this.onGround) {
            this.sleepTimer = 4;
            this.sleeping = true;
            this.sleepTimerDir = -0.2;
        }
    }
};

/*sleepFrog.prototype.extraCheck = function(x, y, w, h) {
    //Check if there is block in front of beetle
    if (this.x + this.w * 2 > x && this.x + this.w < x + w && this.y + this.h + 0.2 > y && this.y - 0.2 < y + h && this.dir > 0
     || this.x > x && this.x - this.w < x + w && this.y + this.h + 0.2 > y && this.y - 0.2 < y + h && this.dir < 0) {
        this.groundCheck = true;
    }
};*/

sleepFrog.prototype.draw = function() {
    save();
    translate(round(this.x), round(this.y));
    if (this.dir < 0) {translate(this.w, 0);}
    scale(this.dir, 1);
    if (this.hp > 0 && checkBlinking(this)) {
        image("enemySprites", enemyImgs[this.sprite], 0, 0);
    }
    restore();
};


sleepFrog.prototype.takeDamage = function(amount, kb) {
    playSound("sleepFrogHurt" + floor(random(1, 3.9999)), 0.7);
    this.hp -= amount;
    takeKb(this, kb);
};

sleepFrog.prototype.wallTop = function() {
    this.velY = 0;
    this.onGround = true;
    if (this.jumpTimer < 0) {
        this.jumpTimer = 1;
    }
};
sleepFrog.prototype.wallLeft = function() {
    this.dir = -1;
    this.velX = -this.velX;
};
sleepFrog.prototype.wallRight = function() {
    this.dir = 1;
    this.velX = -this.velX;
};
sleepFrog.prototype.wallBottom = function() {
    this.velY = 0;
};


//The array that stores all the enemies(and objects that aren't)
var enemies = [];